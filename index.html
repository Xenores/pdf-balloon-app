<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Drawing Tool</title>
  <!-- App Icon / Favicon -->
	<link rel="icon" type="image/png" href="icon.png" />
  <style>	
    body {
      margin: 0;
      padding-top: 0.8in; 
      font-family: sans-serif;
	  overflow: hidden;
    }

    #controls {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 0.6in;
      background: #f8f8f8;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      gap: 0.12in;
      padding: 0 0.18in;
      z-index: 100;
      font-size: 11pt;
      line-height: 1;
    }

    /* Keep the inputs/buttons sized in absolute units as well */
    #controls label { font-size: 10pt; }
    #controls input, #controls button, #controls select {
      font-size: 9pt;
      height: 0.34in;
      padding: 0 0.09in;
      box-sizing: border-box;
    }
	#controls input[type="number"] {
	  width: 6ch; 
	  height: 0.34in; 
	  padding: 0 0.25em;
	  border-radius: 4px;           /* rounded like buttons */
	  border: 1px solid #ccc;
	  background: #f0f0f0;          /* subtle background */
	  text-align: center;
	  font-size: 9pt;               /* same as other toolbar inputs */
	  cursor: pointer;              /* show pointer on hover */
	  transition: all 0.15s ease;
	}
	#controls input[type="number"]:hover {
	  border-color: #888;
	  background: #e8e8e8;
	}
	#controls input[type="number"]:focus {
	  border-color: #007bff;
	  background: #fff;
	  outline: none;
	}
	
    #controls input[type="color"] { width: 0.4in; height: 0.34in; padding: 0; }
    #controls input[type="text"] { width: 1.6in; }
    #controls button { min-width: 0.5in; }
	#controls input[type="range"] { width: 1.0in;   /* adjust to your liking (e.g. 0.8in, 2in) */
			  height: 0.2in;  /* makes the slider thinner */
			  padding: 0;
	}
	#controls button.active-btn {
	  background: #007bff; 
	  color: white; 
	  border: 1px solid #0056b3;
	}

	#controls button.active-btn:hover {
	  background: #0056b3;
	}

    /* canvas and layers */
    #pdf-canvas {
      border: 1px solid #ccc;
      cursor: grab;
      display: block;
    }
    #container {
      position: relative;
      display: block;
	  /*border: 2px solid red;
	  background: rgba(255,0,0,0.05); */
	  width: 100vw;       /* fixed viewport */
	  height: 100vh;      /* fixed viewport */
	  overflow: auto;     /* scrollable if content (canvas) is bigger */
	  cursor: grab;
    }
    #line-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 5;
      width: 100%;
      height: 100%;
    }
    #balloon-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none; /* balloons themselves use pointer-events:auto */
      z-index: 10;
    }
	
	.toolbar-group {
	  display: flex;
	  align-items: center; 
	  gap: 0.2em;            /* small spacing between label and input */
	}
	.toolbar-group label i {
	  margin-right: 0.15em;
	  color: #333;
	}
	
	.file-group {
	  display: inline-flex;
	  gap: 0.1in;
	  padding: 0.05in 0.12in;
	  background-color: #e0e0e0;  /* light grey */
	  border-radius: 6px;
	  align-items: center;
	}

	.file-group button {
	  border: none; 
	  background: #EAE8E8;
	  cursor: pointer;
	  padding: 0.05in 0.08in;
	  font-size: 1.2em;
	}

	.file-group button:hover {
	  background-color: #d0d0d0;
	  border-radius: 4px;
	}
	
	.file-group .group-label {
	  margin-right: 0in;      /* spacing between label and buttons */
	  font-weight: bold;
	  color: #333;
	  font-size: 0.8em;           /* matches your button text size */
	  white-space: nowrap;       /* prevents wrapping */
	}

    .balloon {
      position: absolute;
      padding: 4px 10px;
	  background: rgb(20, 171, 39);   /* default green */ 
      border-radius: 50px;
      color: white;
      text-align: center;
      font-weight: bold;
      border: 1px solid transparent;
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      cursor: grab;
      user-select: none;
      white-space: nowrap;
    }
	
	#textbox-layer {
	  position: absolute;
	  top: 0;
	  left: 0;
	  z-index: 15; /* above balloons */
	  pointer-events: none; /* individual textboxes will allow typing */
	  width: 100%;
	  height: 100%;
	}

	.textbox {
	  font-family: Helvetica, sans-serif;
	  position: absolute;
	  padding: 6px 8px;   /*  more inner padding: 6px top/bottom, 8px left/right */
	  resize: both;
	  overflow: auto;
	  cursor: text;
	  outline: none;
	  border: 1px solid #333; 					/* solid outline */
	  border-radius: 4px;
	  background: rgba(255,255,255,0.8);
	  pointer-events: auto; 					/* allow editing */
	  transition: border-color 0.15s ease;
	  box-sizing: border-box;
	}
	
	.textbox:hover {
	  border-color: #007bff80; /* faint blue border on hover */
	}
	.textbox:focus {
	  border: 2px solid #007bff;   				/* blue border when editing */
	  background: rgba(255,255,255,1);
	}
	#help-popup {
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  background: rgba(0,0,0,0.5);
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  z-index: 10000;
	}

	#help-popup.hidden {
	  display: none;
	}

	.help-content {
	  background: #fff;
	  color: #222;
	  padding: 20px 30px;
	  border-radius: 12px;
	  max-width: 500px;
	  width: 90%;
	  max-height: 80vh; 
	  overflow-y: auto;         /* Enable vertical scrolling */
	  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
	  position: relative;
	  font-size: 14px;
	  line-height: 1.4;
	}
	
	.help-content i {
	  display: block;          /* places English text on a new line */
	  color: #555;             /* subtle gray */
	  font-style: italic;      /* italic style */
	  font-size: 0.9em;        /* slightly smaller than main text */
	  margin-top: 2px;         /* small spacing between DE and EN lines */
	  line-height: 1.4;
	}


	#help-close {
	  position: absolute;
	  top: 10px;
	  right: 14px;
	  font-size: 22px;
	  cursor: pointer;
	  color: #666;
	}

	#help-close:hover {
	  color: #000;
	}
	
	.confirm-box {
	  background: #f0f0f0;              /* neutral gray background */
	  color: #000;
	  font-family: system-ui, sans-serif;
	  border: 1px solid #888;
	  border-radius: 6px;
	  padding: 18px 24px;
	  max-width: 360px;
	  width: 90%;
	  box-shadow: 0 2px 8px rgba(0,0,0,0.25);
	  text-align: center;
	}

	.confirm-box h3 {
	  margin-top: 0;
	  font-size: 1.1em;
	}

	.confirm-buttons {
	  display: flex;
	  justify-content: center;
	  gap: 10px;
	  margin-top: 16px;
	}

	.confirm-buttons button {
	  min-width: 70px;
	  padding: 4px 12px;
	  border: 1px solid #777;
	  border-radius: 3px;
	  background: #e0e0e0;
	  font-size: 0.9em;
	  cursor: pointer;
	}

	.confirm-buttons button:hover {
	  background: #d0d0d0;
	}


  </style>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";
  </script>

  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  
</head>
<body>
  <div id="controls">
    <!-- Zoom controls -->
	<button id="zoom-out" title="Verkleinern"><i class="fas fa-search-minus"></i></button>
    <input id="zoom-range" type="range" min="10" max="500" step="10" value="100" />
    <span id="zoom-level">100%</span>
	<button id="zoom-in" title="Vergrößern"><i class="fas fa-search-plus"></i></button>
    <input type="file" id="file-input" accept=".pdf,.png,.jpg,.jpeg,.webp" style="display: none;"/>
	<input type="file" id="load-project-input" accept=".json" style="display:none;" />
	
	<div class="toolbar-group file-group">
		<span class="group-label">Öffnen:</span>
		<button id="file-picker-btn" title="Datei öffnen"><i class="fa-regular fa-folder-open" style="font-size: 1.4em;"></i></button>
		<button id="load-project-btn" title="Projekt öffnen"><i class="bi bi-filetype-json" style="font-size: 1.5em;"></i></button>
	</div>

	<span id="pdf-name-label" style="font-weight: bold; color: #007bff; font-size:0.9em;">Keine Datei ausgewählt</span>
	
	<div class="toolbar-group file-group">
		<span class="group-label">Speichern:</span>
		<button id="save-pdf-btn" title="Als PDF speichern"><i class="bi bi-filetype-pdf" style="font-size: 1.5em;"></i></button>
		<button id="save-project-btn" title="Projekt speichern"><i class="bi bi-floppy" style="font-size: 1.4em;"></i></button>
	</div>
	
	<div class="toolbar-group">
		<label for="text-size"> Blasengröße:</label>
		<input type="number" id="text-size" value="16" min="8" max="80" step="2" />
	</div>
    <div class="toolbar-group">
		<label for="balloon-color"> Blasenfarbe:</label>
		<input type="color" id="balloon-color" value="#14ab27" />
	</div>
	<div class="toolbar-group">
		<label for="export-filename">Dateiname:</label>
		<input type="text" id="export-filename" value="bubble drawing" />
	</div>
	
	<button id="undo-btn" title="Rückgängig"><i class="fas fa-undo"></i></button>
	<button id="toggle-line-mode" title="Linienmodus aktivieren"><i class="bi bi-arrow-up-right" style="font-size: 1.3em;"></i></button>
	<button id="toggle-textbox" title="Textfeldmodus aktivieren"><i class="bi bi-textarea-t" style="font-size: 1.4em;"></i></button>
	
	<div class="toolbar-group">
		<label for="textbox-size"><i class="fas fa-text-height"></i> Schriftgröße:</label>
		<input type="number" id="textbox-size" value="14" min="8" max="80" step="2" />
	</div>
	<button id="help-btn" title="Anweisungen">
	  <i class="bi bi-info-circle" style="font-size: 1.3em;"></i>
	</button>
  </div>
  <div id="container">
    <canvas id="pdf-canvas"></canvas>
    <svg id="line-layer"></svg>
    <div id="balloon-layer"></div>
	<div id="textbox-layer"></div>
  </div>
 	<div id="help-popup" class="hidden">
	  <div class="help-content">
		<span id="help-close">&times;</span>
		<h2>Blasen-Zeichenwerkzeug – Anleitung<br><i>Balloon Drawing Tool – Guide</i></h2>
		<p><b>Datei öffnen:</b> Klicke auf <b>„Datei öffnen“</b> und wähle eine PDF- oder Bilddatei zum Öffnen aus. Nachdem die Datei geöffnet wurde, klicken und ziehen Sie, um zu scrollen.<br>
		<i><b>Select File:</b> Click <b>“Select File”</b> and choose a PDF or image file to open. Once loaded, click and drag to scroll.</i></p>

		<p><b>Ballon erstellen:</b> <b>Strg + Klick</b> an einer beliebigen Stelle, um einen Ballon hinzuzufügen. Passe Größe und Farbe mit den Eingabefeldern an. Wähle eine Farbe mit dem Farbwähler (Standard: RGB 20,171,39) oder nutze die Pipette, um eine Farbe direkt aus der PDF zu übernehmen.<br>
		<i><b>Create Balloon:</b> <b>Ctrl + Click</b> anywhere to add a balloon. Adjust its size and color using the input fields. Choose a color with the color picker (default: RGB 20,171,39) or use the eyedropper tool to pick a color directly from the PDF.</i></p>

		<p><b>Ballon löschen:</b> Klicke mit der rechten Maustaste auf einen Ballon, um ihn zu löschen. Optional kannst du die verbleibenden Ballons neu nummerieren.<br>
		<i><b>Delete Balloon:</b> Right-click on a balloon to delete it. Optionally, you can renumber the remaining balloons.</i></p>

		<p><b>Ballon bearbeiten:</b> Doppelklicke auf einen Ballon, um seine Nummer zu ändern. Wenn die eingegebene Nummer bereits existiert, werden die vorhandenen Ballons automatisch um 1 erhöht.<br>
		<i><b>Edit Balloon:</b> Double-click a balloon to change its number. If the entered number already exists, existing balloons will automatically be shifted up by 1.</i></p>

		<p><b>Ballon verschieben:</b> Ziehe den Ballon mit der Maus, um ihn zu verschieben. Ein Raster sorgt dafür, dass er sauber ausgerichtet wird.<br>
		<i><b>Move Balloon:</b> Drag the balloon with your mouse to reposition it. A grid helps keep it neatly aligned.</i></p>

		<p><b>Ballon mit Linie:</b> Aktiviere den <b>„Linienmodus“</b>, um Linien zu Ballons hinzuzufügen. Deaktiviere ihn, um nur Ballons zu erstellen.<br>
		<i><b>Balloon with Line:</b> Enable <b>“Line Mode”</b> to draw connecting lines to balloons. Disable it to create balloons only.</i></p>

		<p><b>Textfeld:</b> Aktiviere den <b>Textfeldmodus</b>, klicke an eine beliebige Stelle, um ein Textfeld zu erstellen, und passe die Größe bei Bedarf an. Drücke <b>Entf</b>, um das Textfeld zu löschen.<br>
		<i><b>Text Field:</b> Enable <b>Text Field Mode</b>, click anywhere to create a text box, and resize it as needed. Press <b>Delete</b> to remove it.</i></p>

		<p><b>Projekt speichern:</b> Speichert alle Anmerkungen und die aktuelle Zoomstufe in einer JSON-Datei, um später weiterzuarbeiten.<br>
		<i><b>Save Project:</b> Saves all annotations and the current zoom level into a JSON file so you can continue later.</i></p>

		<p><b>Projekt öffnen:</b> Klicke auf <b>„Projekt öffnen“</b>, wähle die JSON-Datei und anschließend die PDF-Datei aus. Um ein Projekt auf eine andere Datei zu laden:<br>
		<i><b>Open Project:</b> Click <b>“Open Project”</b>, select the JSON file, and then the PDF. To load a project onto a different file:</i></p>
		
		<ol class="instruction-list">
			<li>Öffne die neue Datei.<br><i>Open the new file.</i></li>
			<li>Klicke auf <b>„Projekt öffnen“</b> und wähle die JSON-Datei.<br><i>Click <b>“Open Project”</b> and select the JSON file.</i></li>
			<li>Klicke auf <b>Abbrechen</b>, wenn nach der PDF gefragt wird.<br><i>Click <b>Cancel</b> when prompted for a PDF.</i></li>
			<li>Bestätige alle Meldungen mit <b>OK</b>.<br><i>Confirm all messages with <b>OK</b>.</i></li>
		 </ol>
		
		<p><b>Als PDF speichern:</b> Erstellt eine PDF mit allen Anmerkungen. Die Zoomstufe beeinflusst die Bildqualität — höherer Zoom = bessere Qualität.<br>
		<i><b>Save as PDF:</b> Creates a PDF containing all annotations. The zoom level affects image quality — higher zoom = better quality.</i></p>

		<p><b>Rückgängig:</b> Klicke auf die Schaltfläche „Rückgängig“, um die letzte Aktion rückgängig zu machen.<br>
		<i><b>Undo:</b> Click the “Undo” button to revert the last action.</i></p>

	  </div>
	</div>
  <script>
    // Globals
    let pdfDoc = null;
    let pageNum = 1;
    let scale = 1.0;                // user-visible zoom (1.0 = 100%)
    let originalFileName = 'document';
    let originalPageWidth = 0;
    let originalPageHeight = 0;
    let currentImage = null;        // store loaded image (if any)
	let isRendering = false;
	let pendingRender = null;
	let isTextBoxMode = false;
	
	const topWhiteSpaceBase = 50;
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const balloonLayer = document.getElementById('balloon-layer');
    const lineLayer = document.getElementById('line-layer');
    const exportFilenameInput = document.getElementById('export-filename');
    const balloonColorInput = document.getElementById('balloon-color');
	const textboxSizeInput = document.getElementById("textbox-size");

    // Zoom UI
    const zoomRange = document.getElementById('zoom-range');
    const zoomLevelSpan = document.getElementById('zoom-level');
    const zoomInBtn = document.getElementById('zoom-in') || null; // may not exist in markup
    const zoomOutBtn = document.getElementById('zoom-out');

    // history + lines
    let historyStack = [];
    let leaderLineMode = false;
    let pendingBalloon = null;
    let lines = []; // {fromX,fromY,toX,toY,color,svgLine,fromBalloon,toBalloon,fromHandle,toHandle}
	
// Browser check: do not allow firefox browser
	(function() {
		const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
		if (isFirefox) {
		  alert("?? This app does not work in Firefox. Please use Chrome, Edge, or another Chromium-based browser.");
		  document.body.innerHTML = "<h2 style='color:red; text-align:center; margin-top:2em;'>This app does not work in Firefox. Please open in a Chrome, Edge, Brave or another Chromium-based browser.</h2>";
		  throw new Error("Firefox detected. App blocked.");
		}
	  })();

// ------------------ Drag-to-Scroll (Pan) Feature ------------------ //
	let isPanning = false;
	let panStartX, panStartY; 
	let panScrollLeft, panScrollTop;

	const container = document.getElementById("container");
	
	container.addEventListener("mousedown", (e) => {
	  // only activate panning if CTRL is NOT pressed and not in textbox mode
	  if (e.ctrlKey || isTextBoxMode) return;

	  isPanning = true;
	  panStartX = e.pageX - container.offsetLeft;
	  panStartY = e.pageY - container.offsetTop;
	  panScrollLeft = container.scrollLeft;
	  panScrollTop = container.scrollTop;
	});

	container.addEventListener("mouseleave", () => {
	  isPanning = false;
	  container.style.cursor = "grab";
	});

	container.addEventListener("mouseup", () => {
	  isPanning = false;
	  container.style.cursor = "grab";
	  canvas.style.cursor = "grab";
	});

	container.addEventListener("mousemove", (e) => {
	  if (!isPanning) return;
	  e.preventDefault();
	  const x = e.pageX - container.offsetLeft;
	  const y = e.pageY - container.offsetTop;
	  const walkX = (x - panStartX);
	  const walkY = (y - panStartY);
	  container.scrollLeft = panScrollLeft - walkX;
	  container.scrollTop = panScrollTop - walkY;
	});

// ---------- file loading ----------
	
	document.getElementById('file-picker-btn').addEventListener('click', () => {
	  document.getElementById('file-input').click();
	});
    document.getElementById('file-input').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
	  
	  originalFileName = file.name;
	  document.getElementById("pdf-name-label").textContent = file.name;
	  document.getElementById("pdf-name-label").style.color = "#007bff";
	  
      if (file.type === 'application/pdf') {
        currentImage = null;
        originalFileName = file.name.replace(/\.pdf$/i, '');
        exportFilenameInput.value = `${originalFileName}_bubble drawing`;

        const reader = new FileReader();
        reader.onload = function () {
        const typedarray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
		  pdfDoc = pdf;
		  renderPage(pageNum).then(() => {
			setPdfScale(scale);
			resetAnnotations();
			historyStack = [];
			saveStateToHistory();
		  });
		});
        };
        reader.readAsArrayBuffer(file);

      } else if (file.type.startsWith('image/')) {
        loadImageFile(file);
      } else {
        alert('Please select a PDF or an image file (PNG, JPG, JPEG, WEBP).');
      }
    });

    function loadImageFile(file) {
      const reader = new FileReader();
      reader.onload = function (e) {
        const img = new Image();
        img.onload = function () {
          currentImage = img;
          pdfDoc = null; // clear any loaded pdf
          originalFileName = file.name.replace(/\.[^/.]+$/, '');
          exportFilenameInput.value = `${originalFileName}_bubble drawing`;
          originalPageWidth = img.width;
          originalPageHeight = img.height;

          // draw at current scale
          setPdfScale(scale);

          resetAnnotations();
          historyStack = [];
          saveStateToHistory();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

// renderPage now RETURNS a promise so callers can chain after rendering completes
    function renderPage(num) {
	  if (!pdfDoc) return Promise.resolve();
	  isRendering = true;
	  return pdfDoc.getPage(num).then(page => {
		const unscaledViewport = page.getViewport({ scale: 1.0 });
		originalPageWidth = unscaledViewport.width;
		originalPageHeight = unscaledViewport.height;

		const viewport = page.getViewport({ scale });
		// scaled header so it zooms with the page
		const scaledTopWhiteSpace = Math.round(topWhiteSpaceBase * scale);

		// canvas should include header + page
		canvas.width = Math.round(viewport.width);
		canvas.height = Math.round(viewport.height + scaledTopWhiteSpace);

		// clear and paint white header area
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.fillStyle = 'white';
		ctx.fillRect(0, 0, canvas.width, scaledTopWhiteSpace);
		
		ctx.save();
		ctx.translate(0, scaledTopWhiteSpace);
		
		const renderContext = { canvasContext: ctx, viewport: viewport };
		const renderPromise = page.render(renderContext).promise;
		
		renderPromise
		  .then(() => {
			ctx.restore();
			isRendering = false;

			// adjust overlay sizes
			balloonLayer.style.width = canvas.width + 'px';
			balloonLayer.style.height = canvas.height + 'px';
			lineLayer.setAttribute('width', canvas.width);
			lineLayer.setAttribute('height', canvas.height);
			lineLayer.style.width = canvas.width + 'px';
			lineLayer.style.height = canvas.height + 'px';
		  })
		  .catch(err => {
			console.error('Render error:', err);
			isRendering = false; // ⚠️ ensure reset on error
		  });
		
		return renderPromise;
	  });
	}

// ---------- annotation utilities ----------
    function resetAnnotations() {
      balloonLayer.innerHTML = '';
      lineLayer.innerHTML = '';
      lines = [];
      pendingBalloon = null;
    }
	
// ---------- helper / history functions ----------
    function saveStateToHistory() {
	  const balloonData = [];
	  balloonLayer.querySelectorAll('.balloon').forEach(balloon => {
		const left = parseFloat(balloon.style.left) || 0;
		const top  = parseFloat(balloon.style.top) || 0;
		const width = balloon.offsetWidth;
		const height = balloon.offsetHeight;

		// Save normalized center coordinates (independent of zoom)
		const centerX = left + width / 2;
		const centerY = top + height / 2;

		balloonData.push({
		  text: balloon.textContent,
		  xNorm: centerX / canvas.width,
		  yNorm: centerY / canvas.height,
		  fontSizeNorm: (parseFloat(balloon.style.fontSize) || 16) / scale,
		  color: balloon.style.backgroundColor
		});
	  });
	  
	  const lineData = lines.map(l => ({
		fromXNorm: l.fromX / canvas.width,
		fromYNorm: l.fromY / canvas.height,
		toXNorm:   l.toX / canvas.width,
		toYNorm:   l.toY / canvas.height,
		color: l.color,
		fromLabel: l.fromBalloon ? l.fromBalloon.textContent : null,
		toLabel:   l.toBalloon ? l.toBalloon.textContent : null
	  }));

	  historyStack.push({ balloons: balloonData, lines: lineData });
	}

    function restoreLastState() {
      if (historyStack.length < 2) return;
      historyStack.pop();
      const prev = historyStack[historyStack.length - 1];
	  
      balloonLayer.innerHTML = '';
      lineLayer.innerHTML = '';
      lines = [];
	  
	  const balloonMap = {}; // Rebuild balloons first and keep a lookup by text
      prev.balloons.forEach(d => {
        const b = createBalloonFromData(d);
        balloonLayer.appendChild(b);
		balloonMap[d.text] = b;
      });
	  
	  prev.lines.forEach(l => {
		let fromX = l.fromXNorm * canvas.width;
		let fromY = l.fromYNorm * canvas.height;
		let toX   = l.toXNorm   * canvas.width;
		let toY   = l.toYNorm   * canvas.height;
		const fromBalloon = balloonMap[l.fromLabel] || null;
		const toBalloon   = balloonMap[l.toLabel] || null;

		if (fromBalloon) {
		  const rect = fromBalloon.getBoundingClientRect();
		  const cont = balloonLayer.getBoundingClientRect();
		  fromX = rect.left - cont.left + rect.width / 2;
		  fromY = rect.top - cont.top + rect.height / 2;
		}
		if (toBalloon) {
		  const rect = toBalloon.getBoundingClientRect();
		  const cont = balloonLayer.getBoundingClientRect();
		  toX = rect.left - cont.left + rect.width / 2;
		  toY = rect.top - cont.top + rect.height / 2;
		}
		
		drawLineBetween(fromX, fromY, toX, toY, l.color, fromBalloon, toBalloon); 
      });
    }
	
	document.getElementById('undo-btn').addEventListener('click', restoreLastState);

	function createBalloonFromData(data) {
	  const balloon = document.createElement('div');
	  balloon.className = 'balloon';
	  balloon.textContent = data.text;
	  // Use normalized font size
	  const fontSize = (data.fontSizeNorm || 16) * scale;
	  balloon.style.fontSize = fontSize + 'px';
	  balloon.style.backgroundColor = data.color || balloonColorInput.value;
	  balloon.style.borderColor = darkenColor(balloon.style.backgroundColor, 0.6);
	  balloon.style.position = 'absolute';
	  
	  balloonLayer.appendChild(balloon);

	  // Compute position based on normalized coordinates
	  const centerX = data.xNorm * canvas.width;
	  const centerY = data.yNorm * canvas.height;

	  // Adjust for current balloon size
	  const width = balloon.offsetWidth;
	  const height = balloon.offsetHeight;
	  balloon.style.left = (centerX - width / 2) + 'px';
	  balloon.style.top = (centerY - height / 2) + 'px';

	  attachBalloonEvents(balloon);
	  return balloon;
	}

    function darkenColor(color, factor = 0.7) {
      if (!color) return color;
      if (color.startsWith('#')) {
        let r = parseInt(color.substr(1,2),16),
            g = parseInt(color.substr(3,2),16),
            b = parseInt(color.substr(5,2),16);
        r = Math.floor(r * factor); g = Math.floor(g * factor); b = Math.floor(b * factor);
        return `rgb(${r},${g},${b})`;
      }
      return color;
    }

    function createNewBalloon(x, y, fontSize) {
      const color = balloonColorInput.value;
      const text = getNextBalloonNumber().toString();

      const balloon = document.createElement('div');
      balloon.className = 'balloon';
      balloon.textContent = text;
      balloon.style.fontSize = fontSize + 'px';
      balloon.style.backgroundColor = color;
      balloon.style.borderColor = darkenColor(color, 0.6);

      balloonLayer.appendChild(balloon);
      const rect = balloon.getBoundingClientRect();
      // containerRect used for center alignment calculation
      const containerRect = balloonLayer.getBoundingClientRect();
      const left = x - rect.width / 2;
      const top = y - rect.height / 2;
      balloon.style.left = left + 'px';
      balloon.style.top = top + 'px';

      attachBalloonEvents(balloon);
      return balloon;
    }


    function getNextBalloonNumber() {
      const all = balloonLayer.querySelectorAll('.balloon');
      let max = 0;
      all.forEach(b => {
        const num = parseInt(b.textContent);
        if (!isNaN(num) && num > max) max = num;
      });
      return max + 1;
    }
	
	// Helper: split balloon label into base number + suffix (e.g. "9a" -> { base: 9, suffix: "a" })
	// Helper: split label into either a number or a single letter
	
	function splitLabel(text) {
	  const t = String(text || '').trim();

	  // Pure number?
	  if (/^\d+$/.test(t)) {
		return { type: "number", base: parseInt(t, 10), suffix: "" };
	  }

	  // Starts with digits + suffix
	  const match = t.match(/^(\d+)(.+)$/);
	  if (match) {
		return { type: "numberSuffix", base: parseInt(match[1], 10), suffix: match[2] };
	  }

	  // Single letter (A, b, etc.)
	  if (/^[a-zA-Z]$/.test(t)) {
		return { type: "letter", value: t };
	  }

	  // Everything else
	  return { type: "other", value: t };
	}


	function renumberAfterDeletion(deletedLabel) {
	  const info = splitLabel(deletedLabel);

	  // Case 1: deleted was a number or number+suffix
	  if (info.type === "number" || info.type === "numberSuffix") {
		balloonLayer.querySelectorAll('.balloon').forEach(b => {
		  const bi = splitLabel(b.textContent);

		  if ((bi.type === "number" || bi.type === "numberSuffix") && bi.base > info.base) {
			// Shift down the base
			b.textContent = (bi.base - 1) + (bi.suffix || "");
		  }
		});
	  }

	  // Case 2: deleted was a letter
	  else if (info.type === "letter") {
		balloonLayer.querySelectorAll('.balloon').forEach(b => {
		  const bi = splitLabel(b.textContent);

		  if (bi.type === "letter" && bi.value > info.value) {
			b.textContent = String.fromCharCode(bi.value.charCodeAt(0) - 1);
		  }
		});
	  }

	  // Case 3: "other" → no renumbering
	}
	
	function renumberForInsertion(newLabel, editedBalloon) {
	  const info = splitLabel(newLabel);

	  // Only act if it's a pure number (not "2a", "A", etc.)
	  if (info.type === "number") {
		// Check if that number already exists
		let exists = false;
		balloonLayer.querySelectorAll('.balloon').forEach(b => {
		  if (b === editedBalloon) return; // skip the one being edited
		  const bi = splitLabel(b.textContent);
		  if (bi.type === "number" && bi.base === info.base) {
			exists = true;
		  }
		});

		// Only shift others if that number already exists
		if (exists) {
		  balloonLayer.querySelectorAll('.balloon').forEach(b => {
			if (b === editedBalloon) return;
			const bi = splitLabel(b.textContent);
			if ((bi.type === "number" || bi.type === "numberSuffix") && bi.base >= info.base) {
			  b.textContent = (bi.base + 1) + (bi.suffix || "");
			}
		  });
		}
	  }

	  // If user entered "2a" or letters etc. → do nothing
	}

    // drag/edit/delete balloons (same logic as before)
    function attachBalloonEvents(balloon) {
      let isDragging = false;
      let offsetX, offsetY;

      balloon.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.stopPropagation();
        isDragging = true;
        const rect = balloon.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const containerRect = balloonLayer.getBoundingClientRect();
        const x = e.clientX - containerRect.left - offsetX;
        const y = e.clientY - containerRect.top - offsetY;
        const gridSize = 5; // px per grid cell
		const snapX = Math.round(x / gridSize) * gridSize;
		const snapY = Math.round(y / gridSize) * gridSize;
		
		balloon.style.left = snapX + 'px';
		balloon.style.top = snapY + 'px';
        updateLinesForBalloon(balloon);
      });

      document.addEventListener('mouseup', e => {
        if (isDragging) {
          isDragging = false;
          document.body.style.userSelect = '';
          saveStateToHistory();
        }
      });
	  
	  balloon.addEventListener('dblclick', e => {
		  e.stopPropagation();

		  const oldText = balloon.textContent;
		  const newText = prompt('Edit balloon text:', oldText);

		  if (newText !== null && newText.trim() !== '' && newText.trim() !== oldText) {
			  const trimmed = newText.trim();

			  // Shift other balloons before applying the new number
			  renumberForInsertion(trimmed, balloon);

			  // Now apply the user’s new label
			  balloon.textContent = trimmed;

			  const fontSize = parseInt(document.getElementById('text-size').value) || 16;
			  balloon.style.fontSize = (fontSize * scale) + 'px';

			  // Keep balloon centered (same as before)
			  const rect = balloon.getBoundingClientRect();
			  const containerRect = balloonLayer.getBoundingClientRect();
			  const centerX = rect.left - containerRect.left + rect.width / 2;
			  const centerY = rect.top - containerRect.top + rect.height / 2;

			  balloon.style.left = '0px';
			  balloon.style.top = '0px';
			  const newRect = balloon.getBoundingClientRect();
			  balloon.style.left = (centerX - newRect.width / 2) + 'px';
			  balloon.style.top = (centerY - newRect.height / 2) + 'px';

			  saveStateToHistory();
			}
		});

	  balloon.addEventListener('contextmenu', e => {
		  e.preventDefault();
		  e.stopPropagation();

		  // Create popup using same modal base, but simpler confirm-like style
		  const popup = document.createElement('div');
		  popup.id = 'help-popup'; // reuse same overlay
		  popup.innerHTML = `
			<div class="confirm-box">
			  <h3>Ballon löschen</h3>
			  <p>Ballons nach dem Löschen neu nummerieren?</p>
			  <div class="confirm-buttons">
				<button id="confirm-yes">Ja</button>
				<button id="confirm-no">Nein</button>
				<button id="confirm-cancel">Abbrechen</button>
			  </div>
			</div>
		  `;
		  document.body.appendChild(popup);

		  const cleanup = () => popup.remove();

		  popup.querySelector('#confirm-yes').onclick = () => {
			cleanup();
			proceedDeletion(true);
		  };
		  popup.querySelector('#confirm-no').onclick = () => {
			cleanup();
			proceedDeletion(false);
		  };
		  popup.querySelector('#confirm-cancel').onclick = cleanup;

		  function proceedDeletion(shouldRenumber) {
			const deletedLabel = balloon.textContent;
			balloon.remove();
			removeLinesConnectedTo(balloon);

			if (pendingBalloon?.balloon === balloon) {
			  pendingBalloon = null;
			}
			if (shouldRenumber) {
			  renumberAfterDeletion(deletedLabel);
			}
			saveStateToHistory();
		  }
		});

    }

    function updateLinesForBalloon(balloon) {
      const rect = balloon.getBoundingClientRect();
      const containerRect = balloonLayer.getBoundingClientRect();
      const centerX = rect.left - containerRect.left + rect.width / 2;
      const centerY = rect.top - containerRect.top + rect.height / 2;
      const newColor = balloon.style.backgroundColor;

      lines.forEach((line, index) => {
        let updated = false;
        if (line.fromBalloon === balloon) {
          line.fromX = centerX;
          line.fromY = centerY;
          line.color = newColor;
          updated = true;
        }
        if (line.toBalloon === balloon) {
          line.toX = centerX;
          line.toY = centerY;
          line.color = newColor;
          updated = true;
        }
        if (updated) updateLineSVG(index, line);
      });
    }

    function approxEqual(a, b, tolerance = 3) {
      return Math.abs(a - b) < tolerance;
    }

    function removeLinesConnectedTo(balloon) {
	  lines = lines.filter(line => {
		const connected = (line.fromBalloon?.isSameNode(balloon)) ||
						  (line.toBalloon?.isSameNode(balloon));
		if (connected) {
		  line.svgLine?.remove();
		  line.fromHandle?.remove();
		  line.toHandle?.remove();
		}
		return !connected;
	  });
	}


    function updateLineSVG(index, line) {
      const svgLine = line.svgLine;
      if (svgLine) {
        svgLine.setAttribute('x1', line.fromX);
        svgLine.setAttribute('y1', line.fromY);
        svgLine.setAttribute('x2', line.toX);
        svgLine.setAttribute('y2', line.toY);
        svgLine.setAttribute('stroke', line.color);
        if (line.fromHandle) {
          line.fromHandle.setAttribute('cx', line.fromX);
          line.fromHandle.setAttribute('cy', line.fromY);
        }
        if (line.toHandle) {
          line.toHandle.setAttribute('cx', line.toX);
          line.toHandle.setAttribute('cy', line.toY);
        }
      }
    }

    function drawLineBetween(x1, y1, x2, y2, color = balloonColorInput.value, fromBalloon = null, toBalloon = null) {
	  const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
	  lineEl.setAttribute('x1', x1);
	  lineEl.setAttribute('y1', y1);
	  lineEl.setAttribute('x2', x2);
	  lineEl.setAttribute('y2', y2);
	  lineEl.setAttribute('stroke', color);
	  lineEl.setAttribute('stroke-width', '2');
	  lineLayer.appendChild(lineEl);

	  const currentLine = {
		fromX: x1, fromY: y1,
		toX: x2, toY: y2,
		color, svgLine: lineEl,
		fromBalloon, toBalloon,
		fromHandle: null, toHandle: null
	  };

	  // create draggable handles
	  const fromHandle = createLineHandle(x1, y1, color, (nx, ny) => {
		currentLine.fromX = nx;
		currentLine.fromY = ny;
		updateLineSVG(lines.indexOf(currentLine), currentLine);
	  });
	  const toHandle = createLineHandle(x2, y2, color, (nx, ny) => {
		currentLine.toX = nx;
		currentLine.toY = ny;
		updateLineSVG(lines.indexOf(currentLine), currentLine);
	  });

	  lineLayer.appendChild(fromHandle);
	  lineLayer.appendChild(toHandle);

	  currentLine.fromHandle = fromHandle;
	  currentLine.toHandle = toHandle;

	  lines.push(currentLine);
	  updateLineSVG(lines.length - 1, currentLine);
	}


    // ---------- line handles (optional) ----------
    // kept for completeness — you can hook handle creation to selection if desired
    function createLineHandle(x, y, color, onDrag) {
      const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      handle.setAttribute('cx', x);
      handle.setAttribute('cy', y);
      handle.setAttribute('r', 6);
      handle.setAttribute('fill', 'white');
      handle.setAttribute('stroke', color);
      handle.setAttribute('stroke-width', 2);
      handle.style.cursor = 'move';
      handle.style.pointerEvents = 'all';

      let isDragging = false;
      handle.addEventListener('mousedown', e => { e.stopPropagation(); isDragging = true; });
      
	  document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        const nx = e.clientX - rect.left;
        const ny = e.clientY - rect.top;
        handle.setAttribute('cx', nx);
        handle.setAttribute('cy', ny);
        onDrag(nx, ny);
		// --- NEW: update normalized coordinates so zoom stays accurate ---
		lines.forEach(line => {
			if (line.fromHandle === handle && !line.fromBalloon) {
			  line.fromXNorm = nx / canvas.width;
			  line.fromYNorm = ny / canvas.height;
			}
			if (line.toHandle === handle && !line.toBalloon) {
			  line.toXNorm = nx / canvas.width;
			  line.toYNorm = ny / canvas.height;
			}
		});
      });
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          saveStateToHistory();
        }
      });

      return handle;
    }
	
    // ---------- leader line mode toggle + clicks to create balloons/lines ----------
    document.getElementById('toggle-line-mode').addEventListener('click', () => {
	  leaderLineMode = !leaderLineMode;
	  pendingBalloon = null;

	  const btn = document.getElementById('toggle-line-mode');
	  btn.title = leaderLineMode ? 'Linienmodus deaktivieren' : 'Linienmodus aktivieren';
	  btn.classList.toggle('active-btn', leaderLineMode);
	});

    canvas.addEventListener('click', e => {
	  if (e.ctrlKey && e.button === 0) {
		  if (isTextBoxMode) return; // skip balloon creation if text mode is on
		  
		  const rect = canvas.getBoundingClientRect();
		  const x = e.clientX - rect.left;
		  const y = e.clientY - rect.top;
		  const textSize = parseInt(document.getElementById('text-size').value) || 16;
		  const scaledFontSize = textSize * scale;
		  
		  if (leaderLineMode) {
			if (!pendingBalloon || !pendingBalloon.balloon?.isConnected) {
			  // Only create balloon, DO NOT save yet
			  const balloon = createNewBalloon(x, y, scaledFontSize);
			  pendingBalloon = { balloon, centerX: x, centerY: y };
			  //saveStateToHistory();
			} else {
			  drawLineBetween(pendingBalloon.centerX, pendingBalloon.centerY, x, y, pendingBalloon.balloon.style.backgroundColor, pendingBalloon.balloon, null);
			  pendingBalloon = null;
			  saveStateToHistory();
			}
		  } else {
			createNewBalloon(x, y, scaledFontSize);
			saveStateToHistory();
		  }
		}
    });
	
	// -------------Text Box Size Input -------------------------- //
	textboxSizeInput.addEventListener("input", () => {
	  const size = parseInt(textboxSizeInput.value) || 14;

	  // If a textbox is focused (clicked into), change its font size
	  const active = document.activeElement;
	  if (active && active.classList.contains("textbox")) {
		active.style.fontSize = size + "px";
		saveStateToHistory();
	  }
	});
	
	function trackTextBoxResize(tb) {
	  const observer = new ResizeObserver(() => {
		tb.dataset.wNorm = tb.offsetWidth / canvas.width;
		tb.dataset.hNorm = tb.offsetHeight / canvas.height;
	  });
	  observer.observe(tb);
	}

	// -------------Text Box Drag Function -----------------------//
	function makeTextBoxDraggable(tb) {
	  let isDragging = false;
	  let offsetX = 0, offsetY = 0;
	  const edgeMargin = 6; // px area to detect drag edges

	  tb.addEventListener("mousemove", e => {
		const rect = tb.getBoundingClientRect();
		const onEdge =
		  e.offsetX < edgeMargin ||
		  e.offsetY < edgeMargin ||
		  e.offsetX > rect.width - edgeMargin ||
		  e.offsetY > rect.height - edgeMargin;

		// Don’t override cursor if over native resize handles
		const nearCorner = e.offsetX > rect.width - 12 && e.offsetY > rect.height - 12;
		tb.style.cursor = nearCorner ? "se-resize" : onEdge ? "move" : "text";
	  });

	  tb.addEventListener("mousedown", e => {
		e.stopPropagation();
		const rect = tb.getBoundingClientRect();
		const nearCorner = e.offsetX > rect.width - 12 && e.offsetY > rect.height - 12;
		if (nearCorner) return; // let browser resize

		const onEdge =
		  e.offsetX < edgeMargin ||
		  e.offsetY < edgeMargin ||
		  e.offsetX > rect.width - edgeMargin ||
		  e.offsetY > rect.height - edgeMargin;

		if (onEdge) {
		  isDragging = true;
		  const containerRect = textboxLayer.getBoundingClientRect();
		  offsetX = e.clientX - rect.left;
		  offsetY = e.clientY - rect.top;
		  e.preventDefault();
		  tb.style.cursor = "move";
		} else {
		  tb.focus();
		}
	  });

	  document.addEventListener("mousemove", e => {
		if (!isDragging) return;
		const containerRect = textboxLayer.getBoundingClientRect();
		const x = e.clientX - containerRect.left - offsetX;
		const y = e.clientY - containerRect.top - offsetY;
		tb.style.left = x + "px";
		tb.style.top = y + "px";
		tb.dataset.xNorm = x / canvas.width;
		tb.dataset.yNorm = y / canvas.height;
	  });

	  document.addEventListener("mouseup", () => {
		if (isDragging) {
		  isDragging = false;
		  tb.style.cursor = "text";
		  saveStateToHistory();
		}
	  });
	}


	// --------------Text Box -------------------------------
	document.getElementById("toggle-textbox").addEventListener("click", () => {	  
	  if (document.activeElement.classList.contains("textbox")) {
		document.activeElement.blur();
	  }
	  currentTextBox = null;
	  isTextBoxMode = !isTextBoxMode;

	  const btn = document.getElementById("toggle-textbox");
	  btn.title = isTextBoxMode ? "Textfeldmodus deaktivieren" : "Textfeldmodus aktivieren";

	  btn.classList.toggle("active-btn", isTextBoxMode);
	  textboxLayer.style.pointerEvents = isTextBoxMode ? "auto" : "none";

	});
	
	let currentTextBox = null;
	let startX, startY;

	const textboxLayer = document.getElementById("textbox-layer");

	textboxLayer.addEventListener("mousedown", e => {
	  if (!isTextBoxMode) return;
	  
	  if (document.activeElement.classList.contains("textbox")) return;
	   
	  if (e.target.classList.contains("textbox") || e.target.closest(".textbox")) {
		return; // If clicking inside an existing textbox, do nothing (let it be resized/edited)
	  }
	  
	  const startX = e.offsetX;
	  const startY = e.offsetY;
	  
	  currentTextBox = document.createElement("div"); 
	  
	  currentTextBox.classList.add("textbox");
	  currentTextBox.contentEditable = "true";
	  currentTextBox.style.left = startX + "px";
	  currentTextBox.style.top = startY + "px";
	  currentTextBox.style.minWidth = "50px";
	  currentTextBox.style.minHeight = "20px";
	  currentTextBox.style.fontSize = textboxSizeInput.value + "px";

	  // store normalized position/size so zoom works
	  currentTextBox.dataset.xNorm = startX / canvas.width;
	  currentTextBox.dataset.yNorm = startY / canvas.height;
	  currentTextBox.dataset.wNorm = (parseFloat(currentTextBox.style.width) || 50) / canvas.width;
	  currentTextBox.dataset.hNorm = (parseFloat(currentTextBox.style.height) || 20) / canvas.height;

	  textboxLayer.appendChild(currentTextBox);
	  makeTextBoxDraggable(currentTextBox);
	  trackTextBoxResize(currentTextBox);
	  setTimeout(() => {
		  currentTextBox.focus();
		}, 0);
	// ----- DISABLE TEXT BOX MODE AFTER FIRST CREATION -----
	  isTextBoxMode = false;
	  const btn = document.getElementById("toggle-textbox");
	  btn.classList.remove("active-btn");
	  btn.title = "Textfeldmodus aktivieren";
	  textboxLayer.style.pointerEvents = "none";
	  
	  function resize(eMove) {
		if (!currentTextBox) return;
		currentTextBox.style.width = (eMove.offsetX - startX) + "px";
		currentTextBox.style.height = (eMove.offsetY - startY) + "px";
	  }

	  function stop() {
		textboxLayer.removeEventListener("mousemove", resize);
		textboxLayer.removeEventListener("mouseup", stop);
		currentTextBox.focus();
		// normalize final size
		currentTextBox.dataset.wNorm = (parseFloat(currentTextBox.style.width) || currentTextBox.offsetWidth) / canvas.width;
		currentTextBox.dataset.hNorm = (parseFloat(currentTextBox.style.height) || currentTextBox.offsetHeight) / canvas.height;

		saveStateToHistory();
	  }

	  textboxLayer.addEventListener("mousemove", resize);
	  textboxLayer.addEventListener("mouseup", stop);
	});

// --------------Delete text box with delete key------------- //
	document.addEventListener("keydown", e => {
	  if ((e.key === "Delete") &&
		  document.activeElement.classList.contains("textbox")) {
		const tb = document.activeElement;
		tb.remove();
		saveStateToHistory();
	  }
	});
	
// ---------- export to PDF (lines + balloons scaled back to original doc size) ----------
    document.getElementById('save-pdf-btn').addEventListener('click', async () => {
      try {
        // choose export filename
        const filename = exportFilenameInput.value.trim() || `${originalFileName}_bubble drawing`;
        const { jsPDF } = window.jspdf;

        // If originalPageWidth/Height are in points for PDF case; for images we used pixels
        const isLandscape = originalPageWidth > originalPageHeight;
        const pdf = new jsPDF({
          orientation: isLandscape ? 'landscape' : 'portrait',
          unit: 'pt',
          format: [originalPageWidth, originalPageHeight],
        });

        // scale factors from current canvas (display size) back to original doc size
        const scaleX = originalPageWidth / canvas.width;
        const scaleY = originalPageHeight / canvas.height;

        const imgData = canvas.toDataURL('image/jpeg');
        pdf.addImage(imgData, 'JPEG', 0, 0, originalPageWidth, originalPageHeight);

        // draw lines
        lines.forEach(line => {
          const rgb = parseCssColor(line.color);
          if (rgb) pdf.setDrawColor(rgb.r, rgb.g, rgb.b);
          else pdf.setDrawColor(0,0,0);
		  
          pdf.setLineWidth(1);
          pdf.line(line.fromX * scaleX, line.fromY * scaleY, line.toX * scaleX, line.toY * scaleY);
        });

        // draw balloons as ellipses & text
        balloonLayer.querySelectorAll('.balloon').forEach(balloon => {
          const left = parseFloat(balloon.style.left) || 0;
          const top = parseFloat(balloon.style.top) || 0;
          const rect = balloon.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;
          const text = balloon.textContent;
          const fontSize = parseFloat(window.getComputedStyle(balloon).fontSize) || 16;

          const fillRgb = parseCssColor(balloon.style.backgroundColor);
          if (fillRgb) pdf.setFillColor(fillRgb.r, fillRgb.g, fillRgb.b);
          else pdf.setFillColor(255,0,0);
          pdf.setDrawColor(0,0,0);
          pdf.setLineWidth(2);

          const scaledLeft = left * scaleX;
          const scaledTop  = top  * scaleY;
          const scaledWidth = width * scaleX;
          const scaledHeight = height * scaleY;
          const scaledFontSize = fontSize * scaleX;

          pdf.ellipse(scaledLeft + scaledWidth/2, scaledTop + scaledHeight/2, scaledWidth/2, scaledHeight/2, 'F');
          pdf.setTextColor(255,255,255);
          pdf.setFont("helvetica","bold");
          pdf.setFontSize(scaledFontSize);
          const yOffset = scaledFontSize * 0.35;
          pdf.text(text, scaledLeft + scaledWidth/2, scaledTop + scaledHeight/2 + yOffset, { align: 'center' });
        });
		
		
		// Refresh normalized positions and sizes of all textboxes
		textboxLayer.querySelectorAll('.textbox').forEach(tb => {
		  const left = parseFloat(tb.style.left) || 0;
		  const top = parseFloat(tb.style.top) || 0;
		  const width = tb.offsetWidth;
		  const height = tb.offsetHeight;

		  tb.dataset.xNorm = left / canvas.width;
		  tb.dataset.yNorm = top / canvas.height;
		  tb.dataset.wNorm = width / canvas.width;
		  tb.dataset.hNorm = height / canvas.height;
		});
	  // Text box export
		textboxLayer.querySelectorAll('.textbox').forEach(tb => {
		  const text = tb.innerText.trim();
		  if (!text) return;

		  // Use normalized values (fallback to measured if missing)
		  const xNorm = parseFloat(tb.dataset.xNorm) || (parseFloat(tb.style.left) || 0) / canvas.width;
		  const yNorm = parseFloat(tb.dataset.yNorm) || (parseFloat(tb.style.top) || 0) / canvas.height;
		  const wNorm = parseFloat(tb.dataset.wNorm) || tb.offsetWidth / canvas.width;
		  const hNorm = parseFloat(tb.dataset.hNorm) || tb.offsetHeight / canvas.height;

		  const left   = xNorm * originalPageWidth;
		  const top    = yNorm * originalPageHeight;
		  const width  = wNorm * originalPageWidth;
		  const height = hNorm * originalPageHeight;
		  
		  const fontSize = parseFloat(window.getComputedStyle(tb).fontSize) || 12;
		  const scaledFontSize = fontSize * (originalPageWidth / canvas.width);

		  // Draw solid white background
		  pdf.setFillColor(255, 255, 255);   // white
		  pdf.rect(left, top, width, height, "F");		  
		  
		  // Draw solid border
		  pdf.setDrawColor(0, 0, 0); // black
		  pdf.setLineWidth(1);
		  pdf.rect(left, top, width, height);

		  // Draw text inside
		  pdf.setFont("helvetica", "normal");
		  pdf.setFontSize(scaledFontSize);
		  pdf.setTextColor(0,0,0);

		  const wrapped = pdf.splitTextToSize(text, width - 4); //Padding (2) * 2
		  pdf.text(wrapped, left + 2, top + 4, {
		   maxWidth: width - 4,
		   align: "left",
		   baseline: "top"
		  });
		});
	  
	  
        //pdf.save(filename + '.pdf');
		if ('showSaveFilePicker' in window) {
		  const options = {
			suggestedName: filename + '.pdf',
			types: [{
			  description: 'PDF Document',
			  accept: { 'application/pdf': ['.pdf'] }
			}],
		  };
		  const handle = await window.showSaveFilePicker(options);
		  const writable = await handle.createWritable();
		  await writable.write(await pdf.output('arraybuffer'));
		  await writable.close();
		  alert('PDF saved successfully!');
		} else {
		  // fallback for browsers that don't support it
		  pdf.save(filename + '.pdf');
		}
		
		//
      } catch (err) {
        console.error('Failed to save PDF', err);
        alert('Failed to save PDF: ' + err.message);
      }
    });

    // ---------- color parsing helper ----------
    function parseCssColor(color) {
      if (!color) return null;
      if (color.startsWith('rgb')) {
        const nums = color.match(/\d+/g);
        if (nums && nums.length >= 3) return { r: +nums[0], g: +nums[1], b: +nums[2] };
      } else if (color[0] === '#') {
        let r,g,b;
        if (color.length === 7) {
          r = parseInt(color.substr(1,2),16);
          g = parseInt(color.substr(3,2),16);
          b = parseInt(color.substr(5,2),16);
          return { r,g,b };
        } else if (color.length === 4) {
          r = parseInt(color[1] + color[1],16);
          g = parseInt(color[2] + color[2],16);
          b = parseInt(color[3] + color[3],16);
          return { r,g,b }; //aks
        }
      }
      return null;
    }

    // ---------- ZOOM logic (core) ----------
    // setPdfScale(newScale) will scale the canvas (PDF rendering or image redraw),
    // and scale/move existing balloons + lines so they stay at the same places
	function setPdfScale(newScale) {
	  // Clamp scale
	  newScale = Math.max(0.1, Math.min(5.0, newScale));

	  const oldW = canvas.width || 0;
	  const oldH = canvas.height || 0;

	  // Helper to scale balloons based on normalized coordinates
	  function scaleBalloon(b, oldW, oldH, newW, newH) {
		  const rect = b.getBoundingClientRect();
		  const parentRect = balloonLayer.getBoundingClientRect();
		  const centerX = rect.left - parentRect.left + rect.width / 2;
		  const centerY = rect.top - parentRect.top + rect.height / 2;

		  // Always update normalized position (not just first time)
		  b.dataset.xNorm = centerX / oldW;
		  b.dataset.yNorm = centerY / oldH;

		  // Save base font size only once
		  if (!b.dataset.fontSizeBase) {
			const fs = parseFloat(window.getComputedStyle(b).fontSize) || 16;
			b.dataset.fontSizeBase = fs / scale;
		  }

		  // Compute new exact center using normalized coords
		  const newCenterX = parseFloat(b.dataset.xNorm) * newW;
		  const newCenterY = parseFloat(b.dataset.yNorm) * newH;

		  // Scale font proportionally
		  const baseFS = parseFloat(b.dataset.fontSizeBase) || 16;
		  b.style.fontSize = (baseFS * newScale) + 'px';

		  // Measure balloon after font scaling
		  const newRect = b.getBoundingClientRect();
		  b.style.left = newCenterX - newRect.width / 2 + 'px';
		  b.style.top  = newCenterY - newRect.height / 2 + 'px';
		}

	  // Helper to scale textboxes
	  function scaleTextbox(tb, canvasWidth, canvasHeight) {
		if (!tb.dataset.xNorm || !tb.dataset.yNorm) {
		  const left = parseFloat(tb.style.left) || 0;
		  const top  = parseFloat(tb.style.top) || 0;
		  tb.dataset.xNorm = left / oldW;
		  tb.dataset.yNorm = top / oldH;
		}
		tb.style.left = (parseFloat(tb.dataset.xNorm) * canvasWidth) + 'px';
		tb.style.top  = (parseFloat(tb.dataset.yNorm) * canvasHeight) + 'px';
	  }

	  // Helper to scale all lines
	  function scaleLines(canvasWidth, canvasHeight) {
		lines.forEach((line, idx) => {
		  // Initialize normalized coordinates for free-floating lines
		  if (!line.fromBalloon && line.fromXNorm === undefined) {
			line.fromXNorm = line.fromX / oldW;
			line.fromYNorm = line.fromY / oldH;
		  }
		  if (!line.toBalloon && line.toXNorm === undefined) {
			line.toXNorm = line.toX / oldW;
			line.toYNorm = line.toY / oldH;
		  }

		  // Free-floating lines
		  if (!line.fromBalloon) {
			line.fromX = line.fromXNorm * canvasWidth;
			line.fromY = line.fromYNorm * canvasHeight;
		  }
		  if (!line.toBalloon) {
			line.toX = line.toXNorm * canvasWidth;
			line.toY = line.toYNorm * canvasHeight;
		  }

		  // Lines attached to balloons
		  if (line.fromBalloon) {
			const rect = line.fromBalloon.getBoundingClientRect();
			const cont = balloonLayer.getBoundingClientRect();
			line.fromX = rect.left - cont.left + rect.width / 2;
			line.fromY = rect.top  - cont.top  + rect.height / 2;
		  }
		  if (line.toBalloon) {
			const rect = line.toBalloon.getBoundingClientRect();
			const cont = balloonLayer.getBoundingClientRect();
			line.toX = rect.left - cont.left + rect.width / 2;
			line.toY = rect.top  - cont.top  + rect.height / 2;
		  }

		  if (line.svgLine) updateLineSVG(idx, line);
		});
	  }

	  // Determine new canvas size
	  let newW, newH;
	  if (pdfDoc) {
		pdfDoc.getPage(pageNum).then(page => {
		  const viewport = page.getViewport({ scale: newScale });

		  // --- IMPORTANT: include scaled top white space in newH ---
		  const scaledTopWhiteSpace = Math.round(topWhiteSpaceBase * newScale);
		  newW = Math.round(viewport.width);
		  newH = Math.round(viewport.height + scaledTopWhiteSpace);

		  // Scale everything (use oldW/oldH which already included previous header)
		  balloonLayer.querySelectorAll('.balloon')
			.forEach(b => scaleBalloon(b, oldW, oldH, newW, newH));
		  textboxLayer.querySelectorAll('.textbox')
			.forEach(tb => scaleTextbox(tb, newW, newH));

		  // set overlay sizes to include header
		  balloonLayer.style.width = newW + 'px';
		  balloonLayer.style.height = newH + 'px';
		  lineLayer.setAttribute('width', newW);
		  lineLayer.setAttribute('height', newH);
		  lineLayer.style.width = newW + 'px';
		  lineLayer.style.height = newH + 'px';

		  scale = newScale;
		  return renderPage(pageNum).then(() => {
			scaleLines(newW, newH);
			zoomRange.value = Math.round(scale * 100);
			zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
		  });
		}).catch(err => console.error('Scaling PDF failed', err));
	  } else if (currentImage) {
		// compute scaled header and new sizes
		const scaledTopWhiteSpace = Math.round(topWhiteSpaceBase * newScale);
		newW = Math.round(currentImage.width * newScale);
		// full canvas height includes header
		newH = Math.round(currentImage.height * newScale + scaledTopWhiteSpace);

		// Scale everything (positions use canvas coordinates which include header)
		balloonLayer.querySelectorAll('.balloon')
		  .forEach(b => scaleBalloon(b, oldW, oldH, newW, newH));
		textboxLayer.querySelectorAll('.textbox')
		  .forEach(tb => scaleTextbox(tb, newW, newH));
		scaleLines(newW, newH);

		// Resize canvas and redraw scaled image shifted down by header
		canvas.width = newW;
		canvas.height = newH;
		ctx.clearRect(0, 0, newW, newH);

		// fill header white (optional; renderPage for PDFs did that)
		ctx.fillStyle = 'white';
		ctx.fillRect(0, 0, newW, scaledTopWhiteSpace);

		// draw image below header
		ctx.drawImage(currentImage, 0, scaledTopWhiteSpace, newW, newH - scaledTopWhiteSpace);

		balloonLayer.style.width = newW + 'px';
		balloonLayer.style.height = newH + 'px';
		lineLayer.setAttribute('width', newW);
		lineLayer.setAttribute('height', newH);
		lineLayer.style.width = newW + 'px';
		lineLayer.style.height = newH + 'px';

		scale = newScale;
		zoomRange.value = Math.round(scale * 100);
		zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
	  } else {
		// Nothing loaded yet
		scale = newScale;
		zoomRange.value = Math.round(scale * 100);
		zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
	  }
	}

    // ---------- zoom UI wiring ---------- //
    zoomRange.addEventListener('input', () => {
      if (isRendering) return;
	  const val = Number(zoomRange.value) / 100;
      setPdfScale(val);
    });
    zoomOutBtn.addEventListener('click', () => {
      if (isRendering) return;
	  const newPerc = Math.max(10, Math.round(scale*100) - 10);
      setPdfScale(newPerc / 100);
    });
    document.getElementById('zoom-in').addEventListener('click', () => {
      if (isRendering) return;
	  const newPerc = Math.min(500, Math.round(scale*100) + 10);
      setPdfScale(newPerc / 100);
    });

	// --------------Save Project ------------- //
	document.getElementById("save-project-btn").addEventListener("click", async () => {
	  let pageWidth = canvas.width;
	  let pageHeight = canvas.height;
	  if (pdfDoc) {
		  const pdfPageObj = await pdfDoc.getPage(1);
		  const view = pdfPageObj.view;
		  const unscaledPageHeight = view[3];
		  const scaledTopWhiteSpace = topWhiteSpaceBase * scale;

		  pageWidth = view[2];
		  // include top white space in the saved height
		  pageHeight = unscaledPageHeight + scaledTopWhiteSpace / scale;
		}
		
	  const balloonSizeInput = document.getElementById("text-size");
	  const project = {
		meta: {
		  version: 1,
		  originalFileName,
		  scale,
		  balloonSize: parseInt(balloonSizeInput.value) || 16,
		  canvasWidth: canvas.width,
		  canvasHeight: canvas.height,
		  pageWidth,
		  pageHeight,
		  fileType: pdfDoc ? 'pdf' : 'image',
		},
		balloons: Array.from(balloonLayer.querySelectorAll('.balloon')).map(b => ({
		  text: b.textContent,
		  xNorm: (parseFloat(b.style.left) + b.offsetWidth / 2) / pageWidth,
		  yNorm: (parseFloat(b.style.top) + b.offsetHeight / 2) / pageHeight,
		  fontSize: parseFloat(window.getComputedStyle(b).fontSize),
		  color: b.style.backgroundColor
		})),
		lines: lines.map(l => ({
		  fromXNorm: (l.fromX / scale) / pageWidth,
		  fromYNorm: (l.fromY / scale) / pageHeight,
		  toXNorm: (l.toX / scale) / pageWidth,
		  toYNorm: (l.toY / scale) / pageHeight,
		  color: l.color,
		  fromLabel: l.fromBalloon?.textContent || null,
		  toLabel: l.toBalloon?.textContent || null
		})),
		
		textboxes: Array.from(textboxLayer.querySelectorAll('.textbox')).map(tb => {
		  // Use actual PDF page width/height as reference if available
		  const baseWidth = pageWidth || canvas.width;
		  const baseHeight = pageHeight || canvas.height;

		  const leftPx = parseFloat(tb.style.left) || 0;
		  const topPx = parseFloat(tb.style.top) || 0;
		  const widthPx = tb.offsetWidth;
		  const heightPx = tb.offsetHeight;

		  return {
			text: tb.innerText,
			xNorm: leftPx / baseWidth,
			yNorm: topPx / baseHeight,
			wNorm: widthPx / baseWidth,
			hNorm: heightPx / baseHeight,
			fontSize: parseFloat(window.getComputedStyle(tb).fontSize)
		  };
		})
	  };

	  const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
	  const filename = (exportFilenameInput.value.trim() || "bubble drawing") + ".json";

	  if ('showSaveFilePicker' in window) {
		const handle = await window.showSaveFilePicker({
		  suggestedName: filename,
		  types: [{ description: 'JSON Project', accept: { 'application/json': ['.json'] } }]
		});
		const writable = await handle.createWritable();
		await writable.write(blob);
		await writable.close();
		alert("Project saved!");
	  } else {
		const a = document.createElement("a");
		a.href = URL.createObjectURL(blob);
		a.download = filename;
		a.click();
	  }
	});

	// --------------Load Project ------------- //
	document.getElementById("load-project-btn").addEventListener("click", () => {
	  document.getElementById("load-project-input").click();
	});
	
	document.getElementById("load-project-input").addEventListener("change", async e => {
	  const file = e.target.files[0];
	  if (!file) return;

	  const text = await file.text();
	  const project = JSON.parse(text);
	  
	  // --- Show which PDF this project belongs to ---
		const pdfNameLabel = document.getElementById("pdf-name-label");
		if (project.meta?.originalFileName) {
		  pdfNameLabel.textContent = `Projekt für: ${project.meta.originalFileName}`;
		  pdfNameLabel.style.color = "darkorange";
		} else {
		  pdfNameLabel.textContent = "Im Projekt ist kein PDF angegeben.";
		  pdfNameLabel.style.color = "gray";
		}

	  //---- Try to auto-load the original PDF or Image (if info exists) ---
		if (project.meta?.originalFileName) {
		  try {
			if (project.meta.fileType === 'pdf') {
			  const matchingPDF = await promptForMatchingPDF(project.meta.originalFileName);
			  if (matchingPDF) {
				await openPDFFile(matchingPDF);
				exportFilenameInput.value = `${originalFileName}_bubble drawing`;
			  } else {
				alert(`PDF "${project.meta.originalFileName}" not found. Please open it manually first.`);
			  }
			} else if (project.meta.fileType === 'image') {
			  const matchingImage = await promptForMatchingImage(project.meta.originalFileName);
			  if (matchingImage) {
				await openImageFile(matchingImage);
				exportFilenameInput.value = `${originalFileName}_bubble drawing`;
			  } else {
				alert(`Image "${project.meta.originalFileName}" not found. Please open it manually first.`);
			  }
			}
		  } catch (err) {
			console.error('File auto-load failed:', err);
			alert('Die Originaldatei konnte nicht automatisch geladen werden. Bitte öffnen Sie sie zunächst manuell.');
		  }
		}

	  // --- Wait until PDF is fully rendered and scaled ---
		if (project.meta?.fileType === 'pdf' && pdfDoc) {
		  await new Promise(resolve => setTimeout(resolve, 100)); // short wait
		  await setPdfScale(project.meta.scale || scale);
		} else if (project.meta?.fileType === 'image') {
		  await new Promise(resolve => setTimeout(resolve, 100));
		  await setPdfScale(project.meta.scale || scale);
		}
		// --- Now safe to clear and restore annotations ---
		resetAnnotations();
		historyStack = [];

		// --- Now restore everything ---
		restoreProjectAnnotations(project);
	  
	  if (project.meta?.balloonSize) {
		document.getElementById("text-size").value = project.meta.balloonSize;
	  }
	});
	
	function restoreProjectAnnotations(project) {
	  const canvasW = canvas.width;
	  const canvasH = canvas.height;
	  const baseWidth = project.meta?.pageWidth || canvas.width;
	  const baseHeight = project.meta?.pageHeight || canvas.height;

	  const balloonMap = {};
	  project.balloons.forEach(b => {
		const balloon = createBalloonFromData({
		  text: b.text,
		  xNorm: b.xNorm,
		  yNorm: b.yNorm,
		  fontSizeNorm: b.fontSize / scale,
		  color: b.color
		});
		balloonMap[b.text] = balloon;
	  });

	  project.lines.forEach(l => {
		const fromBalloon = l.fromLabel ? balloonMap[l.fromLabel] : null;
		const toBalloon = l.toLabel ? balloonMap[l.toLabel] : null;
		drawLineBetween(
		  l.fromXNorm * canvasW,
		  l.fromYNorm * canvasH,
		  l.toXNorm * canvasW,
		  l.toYNorm * canvasH,
		  l.color,
		  fromBalloon,
		  toBalloon
		);
	  });

	  project.textboxes.forEach(tb => {
		const newBox = document.createElement("div");
		newBox.className = "textbox";
		newBox.contentEditable = "true";
		newBox.innerText = tb.text;
		newBox.style.fontSize = tb.fontSize + "px";
		newBox.style.left = (tb.xNorm * baseWidth) + "px";
		newBox.style.top = (tb.yNorm * baseHeight) + "px";
		newBox.style.width = (tb.wNorm * baseWidth) + "px";
		newBox.style.height = (tb.hNorm * baseHeight) + "px";
		textboxLayer.appendChild(newBox);
		makeTextBoxDraggable(newBox);
		trackTextBoxResize(newBox);
	  });

	  alert("Projekt erfolgreich geladen!");
	}

	async function promptForMatchingPDF(fileName) {
	  // Ask the user to pick a PDF (modern browsers only)
	  if (!('showOpenFilePicker' in window)) return null;

	  const [handle] = await window.showOpenFilePicker({
		types: [{ description: 'PDF Files', accept: { 'application/pdf': ['.pdf'] } }]
	  });

	  const file = await handle.getFile();
	  // Compare filenames loosely (case-insensitive)
	  if (file.name.toLowerCase().includes(fileName.toLowerCase())) {
		return file;
	  }
	  return null;
	}
	
	async function promptForMatchingImage(fileName) {
	  if (!('showOpenFilePicker' in window)) return null;

	  const [handle] = await window.showOpenFilePicker({
		types: [{
		  description: 'Image Files', accept: { 'image/*': ['.png', '.jpg', '.jpeg', '.webp'] }
		}]
	  });

	  const file = await handle.getFile();
	  if (file.name.toLowerCase().includes(fileName.toLowerCase())) {
		return file;
	  }
	  return null;
	}

	async function openPDFFile(file) {
	  return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = function () {
		  const typedarray = new Uint8Array(this.result);
		  pdfjsLib.getDocument(typedarray).promise.then(pdf => {
			pdfDoc = pdf;
			originalFileName = file.name.replace(/\.pdf$/i, '');
			renderPage(pageNum)
			  .then(() => resolve())
			  .catch(err => {
				console.error("PDF render error:", err);
				reject(err);
			  });
		  }).catch(reject);
		};
		reader.onerror = reject;
		reader.readAsArrayBuffer(file);
	  });
	}
	
	async function openImageFile(file) {
	  return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = function (e) {
		  const img = new Image();
		  img.onload = function () {
			const ctx = canvas.getContext('2d');
			currentImage = img;
			canvas.width = img.width;
			canvas.height = img.height;
			ctx.drawImage(img, 0, 0);
			// Set scale appropriately (like with PDFs)
			const scaleX = canvas.clientWidth / img.width;
			const scaleY = canvas.clientHeight / img.height;
			scale = Math.min(scaleX, scaleY);

			originalFileName = file.name.replace(/\.[^/.]+$/, '');
			resolve();
		  };
		  img.onerror = reject;
		  img.src = e.target.result;
		};
		reader.onerror = reject;
		reader.readAsDataURL(file);
	  });
	}

    // ---------- initial UI values ---------- //
    zoomRange.value = Math.round(scale * 100);
    zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
	
	// ---------- Instructions window -------------------------
	document.getElementById("help-btn").addEventListener("click", () => {
	  document.getElementById("help-popup").classList.remove("hidden");
	});

	document.getElementById("help-close").addEventListener("click", () => {
	  document.getElementById("help-popup").classList.add("hidden");
	});

	window.addEventListener("click", (e) => {
	  const popup = document.getElementById("help-popup");
	  if (e.target === popup) popup.classList.add("hidden");
	});

  </script>
</body>
</html>
