<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Balloon Tool with Leader Lines</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }
    #pdf-canvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      display: block;
    }
    #balloon-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none; /* Allow clicks to pass through except balloons */
      z-index: 10;
    }
    #container {
      position: relative;
      display: inline-block;
    }
    #line-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 5;
      width: 100%;
      height: 100%;
    }
    #controls {
      margin: 10px;
    }
    .balloon {
      position: absolute;
	  padding: 4px 10px;
	  background: red;
	  border-radius: 50px; /* large radius to make oval */
	  color: white;
	  text-align: center;
	  font-weight: bold;
	  border: 2px solid black;
	  pointer-events: auto;
	  display: inline-flex;
	  align-items: center;
	  justify-content: center;
	  box-sizing: border-box;
	  cursor: grab;
	  user-select: none;
	  white-space: nowrap; /* prevent wrapping */
    }
  </style>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";
  </script>

  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <div id="controls">
	  <input type="file" id="file-input" accept=".pdf" />
	  <label for="text-size">Text Size:</label>
	  <input type="number" id="text-size" value="16" min="8" max="100" step="1" style="width: 60px" />
	  <label for="balloon-color">üé® Balloon Color:</label>
	  <input type="color" id="balloon-color" value="#ff0000" style="width: 60px; vertical-align: middle" />
	  <label for="export-filename">Filename:</label>
	  <input type="text" id="export-filename" value="ballooned" style="width: 200px" />
	  <button id="save-pdf-btn">üíæ Save as PDF</button>
	  <button id="undo-btn">‚Ü©Ô∏è Undo</button>
	  <button id="toggle-line-mode">Enable Leader Line Mode</button>
  </div>

  <div id="container">
    <canvas id="pdf-canvas"></canvas>
    <svg id="line-layer"></svg>
    <div id="balloon-layer"></div>
  </div>

  <script>
    // Globals
    let pdfDoc = null;
    let pageNum = 1;
    let scale = 3.0;
    let originalFileName = 'document';
	let originalPageWidth = 0;
	let originalPageHeight = 0;

    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const balloonLayer = document.getElementById('balloon-layer');
    const lineLayer = document.getElementById('line-layer');
    const exportFilenameInput = document.getElementById('export-filename');
	const balloonColorInput = document.getElementById('balloon-color');
	
    // State for undo/history
    let historyStack = [];

    // Leader Line mode state
    let leaderLineMode = false;
    let pendingBalloon = null; // Holds balloon waiting for line endpoint
    let lines = []; // Array of line data: {fromX, fromY, toX, toY}

    // Save initial state
    function saveStateToHistory() {
      const balloonData = [];
      balloonLayer.querySelectorAll('.balloon').forEach(balloon => {
        balloonData.push({
          text: balloon.textContent,
          left: balloon.style.left,
          top: balloon.style.top,
          width: balloon.style.width,
          height: balloon.style.height,
          fontSize: balloon.style.fontSize,
          lineHeight: balloon.style.lineHeight,
		  color: balloon.style.backgroundColor,
        });
      });
      // Deep copy of lines array
      const linesCopy = lines.map(line => ({ ...line }));
      historyStack.push({ balloons: balloonData, lines: linesCopy });
    }

    // Restore last state from history
    function restoreLastState() {
      if (historyStack.length < 2) return; // Nothing to undo
      historyStack.pop(); // Remove current state
      const prevState = historyStack[historyStack.length - 1];

      // Clear balloons and lines
      balloonLayer.innerHTML = '';
      lineLayer.innerHTML = '';
      lines = [];

      // Restore balloons
      prevState.balloons.forEach(data => {
        const balloon = createBalloonFromData(data);
        balloonLayer.appendChild(balloon);
      });

      // Restore lines
	  prevState.lines.forEach(line => {
		 drawLineBetween(line.fromX, line.fromY, line.toX, line.toY, line.color);
	  });
    }

    // Undo button handler
    document.getElementById('undo-btn').addEventListener('click', () => {
      restoreLastState();
    });

    // Load PDF and render
    document.getElementById('file-input').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file || file.type !== 'application/pdf') {
        alert('Please select a PDF file.');
        return;
      }

      originalFileName = file.name.replace(/\.pdf$/i, '');
      exportFilenameInput.value = `${originalFileName} - ballooned`;

      const reader = new FileReader();
      reader.onload = function () {
        const typedarray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
          pdfDoc = pdf;
          renderPage(pageNum);
		  console.log("Canvas size:", canvas.width, canvas.height);
          resetAnnotations();
          historyStack = [];
          saveStateToHistory();
        });
      };
      reader.readAsArrayBuffer(file);
    });

    function renderPage(num) {
      pdfDoc.getPage(num).then(page => {
        const unscaledViewport = page.getViewport({ scale: 1.0 });
		originalPageWidth = unscaledViewport.width;
		originalPageHeight = unscaledViewport.height;
		
		console.log("Original PDF page size (pt):", originalPageWidth, originalPageHeight);
		
		const viewport = page.getViewport({ scale });
		canvas.height = viewport.height;
		canvas.width = viewport.width;
		console.log("Viewport (scaled):", viewport.width, viewport.height);
        balloonLayer.style.width = canvas.width + 'px';
        balloonLayer.style.height = canvas.height + 'px';
        lineLayer.setAttribute('width', canvas.width);
        lineLayer.setAttribute('height', canvas.height);
        lineLayer.style.width = canvas.width + 'px';
        lineLayer.style.height = canvas.height + 'px';

        const renderContext = {
          canvasContext: ctx,
          viewport: viewport,
        };
        page.render(renderContext).promise.then(() => {});
      });
    }

    // Reset balloons and lines
    function resetAnnotations() {
      balloonLayer.innerHTML = '';
      lineLayer.innerHTML = '';
      lines = [];
      pendingBalloon = null;
    }
	
    // Create balloon DOM element from data object
    function createBalloonFromData(data) {
	  const balloon = document.createElement('div');
	  balloon.className = 'balloon';
	  balloon.textContent = data.text;
	  balloon.style.left = data.left;
	  balloon.style.top = data.top;
	  balloon.style.width = data.width;
	  balloon.style.height = data.height;
	  balloon.style.lineHeight = data.lineHeight;
	  balloon.style.fontSize = data.fontSize;
	  balloon.style.backgroundColor = data.color || balloonColorInput.value;
	  balloon.style.borderColor = darkenColor(balloon.style.backgroundColor, 0.6);
	  attachBalloonEvents(balloon);
	  return balloon;
	}
	
	// Darken color helper for border
	function darkenColor(color, factor = 0.7) {
	  // Support hex color
	  if (color.startsWith('#')) {
		let r = parseInt(color.substr(1,2),16);
		let g = parseInt(color.substr(3,2),16);
		let b = parseInt(color.substr(5,2),16);
		r = Math.floor(r * factor);
		g = Math.floor(g * factor);
		b = Math.floor(b * factor);
		return `rgb(${r},${g},${b})`;
	  }
	  return color;
	}
	
	// Create balloon with color from picker
	function createNewBalloon(x, y, fontSize) {
	  const color = balloonColorInput.value;
	  const text = getNextBalloonNumber().toString(); // initial balloon text is a number
	  
	  const balloon = document.createElement('div');
	  balloon.className = 'balloon';
	  balloon.textContent = text;
	  balloon.style.fontSize = fontSize + 'px';
	  balloon.style.backgroundColor = color;
	  balloon.style.borderColor = darkenColor(color, 0.6);

	  // Position balloon centered at (x,y)
	  // Since width/height depends on text, we append first, then measure size:
	  balloonLayer.appendChild(balloon);

	  const rect = balloon.getBoundingClientRect();
	  const containerRect = balloonLayer.getBoundingClientRect();

	  // Set position so balloon center aligns with (x,y)
	  const left = x - rect.width / 2;
	  const top = y - rect.height / 2;

	  balloon.style.left = left + 'px';
	  balloon.style.top = top + 'px';

	  attachBalloonEvents(balloon);

	  return balloon;
	}

    // Get next balloon number
    function getNextBalloonNumber() {
      const all = balloonLayer.querySelectorAll('.balloon');
      let max = 0;
      all.forEach(b => {
        const num = parseInt(b.textContent);
        if (!isNaN(num) && num > max) max = num;
      });
      return max + 1;
    }

    // Attach events to balloons (drag, edit, delete)
    function attachBalloonEvents(balloon) {
      // Dragging
      let isDragging = false;
      let offsetX, offsetY;

      balloon.addEventListener('mousedown', e => {
        if (e.button !== 0) return; // left click only
        e.stopPropagation();
        isDragging = true;
        const rect = balloon.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const containerRect = balloonLayer.getBoundingClientRect();
        const x = e.clientX - containerRect.left - offsetX;
        const y = e.clientY - containerRect.top - offsetY;
        balloon.style.left = x + 'px';
        balloon.style.top = y + 'px';
        updateLinesForBalloon(balloon);
      });

      document.addEventListener('mouseup', e => {
        if (isDragging) {
          isDragging = false;
          document.body.style.userSelect = '';
          saveStateToHistory();
        }
      });

      // Edit on click
      balloon.addEventListener('click', e => {
		e.stopPropagation();
		  const newText = prompt('Edit balloon text:', balloon.textContent);
		  if (newText !== null && newText.trim() !== '') {
			balloon.textContent = newText.trim();

			// Update font size to current selected text size
			const fontSize = parseInt(document.getElementById('text-size').value) || 16;
			balloon.style.fontSize = fontSize + 'px';

			// Reposition balloon to keep it centered where it was
			const rect = balloon.getBoundingClientRect();
			const containerRect = balloonLayer.getBoundingClientRect();

			const centerX = rect.left - containerRect.left + rect.width / 2;
			const centerY = rect.top - containerRect.top + rect.height / 2;

			// After text change, measure new size
			// Force reflow before measuring
			balloon.style.left = '0px'; // temp reset
			balloon.style.top = '0px';

			const newRect = balloon.getBoundingClientRect();

			// Calculate new left/top to keep center same
			const newLeft = centerX - newRect.width / 2;
			const newTop = centerY - newRect.height / 2;

			balloon.style.left = newLeft + 'px';
			balloon.style.top = newTop + 'px';

			saveStateToHistory();
		  }
		});

      // Delete on right click
      balloon.addEventListener('contextmenu', e => {
        e.preventDefault();
        e.stopPropagation();
        const deletedNum = parseInt(balloon.textContent);
        const shouldRenumber = confirm('Renumber balloons after deleting?');
        balloon.remove();
		removeLinesConnectedTo(balloon); //Clean up lines
        if (shouldRenumber) {
          balloonLayer.querySelectorAll('.balloon').forEach(b => {
            const num = parseInt(b.textContent);
            if (!isNaN(num) && num > deletedNum) {
              b.textContent = num - 1;
            }
          });
        }
        saveStateToHistory();
      });
    }

    // Update lines connected to a balloon when it moves (leaderLineMode only)
	// Update lines connected to a balloon when it moves or color changes
	function updateLinesForBalloon(balloon) {
	  const rect = balloon.getBoundingClientRect();
	  const containerRect = balloonLayer.getBoundingClientRect();
	  const centerX = rect.left - containerRect.left + rect.width / 2;
	  const centerY = rect.top - containerRect.top + rect.height / 2;
	  const newColor = balloon.style.backgroundColor;

	  lines.forEach((line, index) => {
		const fromMatch = approxEqual(line.fromX, line.balloonFromX) && approxEqual(line.fromY, line.balloonFromY);
		const toMatch = approxEqual(line.toX, line.balloonToX) && approxEqual(line.toY, line.balloonToY);
		// If line endpoint matches balloon center, update pos & color
		if (fromMatch) {
		  line.fromX = centerX;
		  line.fromY = centerY;
		  line.balloonFromX = centerX;
		  line.balloonFromY = centerY;
		  line.color = newColor;
		  updateLineSVG(index, line);
		}
		if (toMatch) {
		  line.toX = centerX;
		  line.toY = centerY;
		  line.balloonToX = centerX;
		  line.balloonToY = centerY;
		  line.color = newColor;
		  updateLineSVG(index, line);
		}
	  });
	}

    function approxEqual(a, b, tolerance = 3) {
      return Math.abs(a - b) < tolerance;
    }

    // Remove lines connected to a balloon (on delete)
	function removeLinesConnectedTo(balloon) {
	  const left = parseFloat(balloon.style.left);
	  const top = parseFloat(balloon.style.top);
	
	  // Use balloonLayer rect to calculate center relative to container
	  const containerRect = balloonLayer.getBoundingClientRect();
	  const balloonRect = balloon.getBoundingClientRect();
	
	  const width = balloonRect.width;
	  const height = balloonRect.height;
	
	  // Calculate center using style.left/top + half width/height
	  const centerX = left + width / 2;
	  const centerY = top + height / 2;
	
	  // Filter lines and remove SVG for connected lines
	  const newLines = [];
	  lines.forEach(line => {
	    const isConnected = (
	      approxEqual(line.fromX, centerX) && approxEqual(line.fromY, centerY)
	    ) || (
	      approxEqual(line.toX, centerX) && approxEqual(line.toY, centerY)
	    );
	
	    if (isConnected) {
	      // Remove SVG element
	      if (line.svgLine) line.svgLine.remove();
	    } else {
	      newLines.push(line);
	    }
	  });
	
	  lines = newLines;
	}

    // Update a line's SVG element by index
    // Update line SVG color when balloon moves or color changes
	function updateLineSVG(index, line) {
	  const svgLine = line.svgLine;
	  if (svgLine) {
		svgLine.setAttribute('x1', line.fromX);
		svgLine.setAttribute('y1', line.fromY);
		svgLine.setAttribute('x2', line.toX);
		svgLine.setAttribute('y2', line.toY);
		svgLine.setAttribute('stroke', line.color);
	  }
	}

    // Draw a new line in SVG and keep in lines, Modified to accept color parameter
    function drawLineBetween(x1, y1, x2, y2, color = balloonColorInput.value) {
	  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
	  line.setAttribute('x1', x1);
	  line.setAttribute('y1', y1);
	  line.setAttribute('x2', x2);
	  line.setAttribute('y2', y2);
	  line.setAttribute('stroke', color);
	  line.setAttribute('stroke-width', '2');
	  lineLayer.appendChild(line);

	  lines.push({
		fromX: x1,
		fromY: y1,
		toX: x2,
		toY: y2,
		balloonFromX: x1,
		balloonFromY: y1,
		balloonToX: x2,
		balloonToY: y2,
		color: color,
		svgLine: line,
	  });
	}
	
    // Toggle Leader Line Mode button
    document.getElementById('toggle-line-mode').addEventListener('click', () => {
      leaderLineMode = !leaderLineMode;
      pendingBalloon = null;
      document.getElementById('toggle-line-mode').textContent = leaderLineMode ? '‚û°Ô∏è Disable Leader Line Mode' : 'Enable Leader Line Mode';
    });

	
	canvas.addEventListener('click', e => {
	  const rect = canvas.getBoundingClientRect();
	  const x = e.clientX - rect.left;
	  const y = e.clientY - rect.top;
	  const textSize = parseInt(document.getElementById('text-size').value) || 16;

	  if (leaderLineMode) {
		if (!pendingBalloon) {
		  saveStateToHistory();
		  const balloon = createNewBalloon(x, y, textSize);
		  pendingBalloon = { balloon, centerX: x, centerY: y };
		} else {
		  saveStateToHistory();
		  drawLineBetween(pendingBalloon.centerX, pendingBalloon.centerY, x, y, pendingBalloon.balloon.style.backgroundColor);
		  pendingBalloon = null;
		}
	  } else {
		saveStateToHistory();
		createNewBalloon(x, y, textSize);
	  }
	});


	// Save PDF - draw lines with their colors
	document.getElementById('save-pdf-btn').addEventListener('click', async () => {
		try {  
		  if (!pdfDoc) {
			alert('Load a PDF first.');
			return;
		  }

		  const { jsPDF } = window.jspdf;
		  
		  const isLandscape = originalPageWidth > originalPageHeight;
		  
		  // Use the unscaled (original) PDF size in points
		  const pdf = new jsPDF({
			orientation: isLandscape ? 'landscape' : 'portrait',
			unit: 'pt',
			format: [originalPageWidth, originalPageHeight],
		  });
		  console.log("jsPDF internal page size (pt):", pdf.internal.pageSize.getWidth(), pdf.internal.pageSize.getHeight());
			
		  // Scale factor to map from canvas (rendered at scale=3) to original size
		  const scaleX = originalPageWidth / canvas.width;
		  const scaleY = originalPageHeight / canvas.height;

		  const imgData = canvas.toDataURL('image/jpeg'); // or 'image/png'
		  const testImg = new Image();
		  testImg.src = imgData;
		  testImg.onload = () => {
			console.log("Image dimensions from canvas.toDataURL:", testImg.width, testImg.height);
		  };
		  pdf.addImage(
			imgData,
			'JPEG',
			0,
			0,
			originalPageWidth,
			originalPageHeight
		  );

		  // Draw lines (scaled)
		  lines.forEach(line => {
			const rgb = parseCssColor(line.color);
			if (rgb) {
			  pdf.setDrawColor(rgb.r, rgb.g, rgb.b);
			} else {
			  pdf.setDrawColor(0, 0, 0);
			}
			pdf.setLineWidth(2);
			pdf.line(
			  line.fromX * scaleX,
			  line.fromY * scaleY,
			  line.toX * scaleX,
			  line.toY * scaleY
			);
		  });

		  // Draw balloons (scaled)
		  balloonLayer.querySelectorAll('.balloon').forEach(balloon => {
			const rect = balloon.getBoundingClientRect();
			const left = parseFloat(balloon.style.left);
			const top = parseFloat(balloon.style.top);
			const width = rect.width;
			const height = rect.height;
			const text = balloon.textContent;
			const fontSize = parseFloat(balloon.style.fontSize) || 16;

			const fillRgb = parseCssColor(balloon.style.backgroundColor);
			if (fillRgb) {
			  pdf.setFillColor(fillRgb.r, fillRgb.g, fillRgb.b);
			} else {
			  pdf.setFillColor(255, 0, 0);
			}
			pdf.setDrawColor(0, 0, 0);
			pdf.setLineWidth(2);

			const scaledLeft = left * scaleX;
			const scaledTop = top * scaleY;
			const scaledWidth = width * scaleX;
			const scaledHeight = height * scaleY;
			const scaledFontSize = fontSize * scaleX;

			pdf.ellipse(
			  scaledLeft + scaledWidth / 2,  // centerX
			  scaledTop + scaledHeight / 2,  // centerY
			  scaledWidth / 2,               // radiusX (half width)
			  scaledHeight / 2,              // radiusY (half height)
			  'F'                           // fill
			);

			pdf.setTextColor(255, 255, 255);
			pdf.setFont("helvetica", "bold");
			pdf.setFontSize(scaledFontSize);

			const yOffset = scaledFontSize * 0.35; // vertical centering adjustment
			pdf.text(
			  text,
			  scaledLeft + scaledWidth / 2,
			  scaledTop + scaledHeight / 2 + yOffset,
			  {
				align: 'center',
			  }
			);
		  });

		  const filename = exportFilenameInput.value.trim() || `${originalFileName}-ballooned`;
		  pdf.save(filename + '.pdf');
		} catch (error) {
			console.error('Error generating PDF:', error);
			alert('Failed to generate PDF: ' + error.message);
		}
	});


	// Helper to parse rgb or hex CSS color string into {r,g,b}
	function parseCssColor(color) {
	  if (!color) return null;
	  if (color.startsWith('rgb')) {
		const nums = color.match(/\d+/g);
		if (nums && nums.length >= 3) {
		  return { r: +nums[0], g: +nums[1], b: +nums[2] };
		}
	  } else if (color[0] === '#') {
		let r, g, b;
		if (color.length === 7) {
		  r = parseInt(color.substr(1, 2), 16);
		  g = parseInt(color.substr(3, 2), 16);
		  b = parseInt(color.substr(5, 2), 16);
		  return { r, g, b };
		} else if (color.length === 4) {
		  r = parseInt(color[1] + color[1], 16);
		  g = parseInt(color[2] + color[2], 16);
		  b = parseInt(color[3] + color[3], 16);
		  return { r, g, b };
		}
	  }
	  return null;
	}
  </script>
</body>
</html>

