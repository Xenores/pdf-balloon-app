<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Balloon Tool with Leader Lines</title>
  <style>	
    body {
      margin: 0;
      padding-top: 0.8in; /* space for fixed toolbar */
      font-family: sans-serif;
    }

    /* top toolbar - kept fixed (use absolute units so it's stable across OS scaling) */
    #controls {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 0.6in;
      background: #f8f8f8;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      gap: 0.12in;
      padding: 0 0.18in;
      z-index: 100;
      font-size: 11pt;
      line-height: 1;
    }

    /* Keep the inputs/buttons sized in absolute units as well */
	/* Default color 85/190/90 or 20/171/39 */
    #controls label { font-size: 10pt; }
    #controls input, #controls button, #controls select {
      font-size: 9pt;
      height: 0.34in;
      padding: 0 0.09in;
      box-sizing: border-box;
    }
    #controls input[type="number"] { width: 0.6in; }
    #controls input[type="color"] { width: 0.4in; height: 0.34in; padding: 0; }
    #controls input[type="text"] { width: 1.6in; }
    #controls button { min-width: 0.5in; }
	#controls input[type="range"] { width: 1.0in;   /* adjust to your liking (e.g. 0.8in, 2in) */
			  height: 0.2in;  /* makes the slider thinner */
			  padding: 0;
	}
	#controls button.active-btn {
	  background: #007bff;   /* blue background */
	  color: white;          /* white text */
	  border: 1px solid #0056b3;
	}

	#controls button.active-btn:hover {
	  background: #0056b3;   /* darker blue on hover */
	}

    /* canvas and layers */
    #pdf-canvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      display: block;
    }
    #container {
      position: relative;
      display: inline-block;
    }
    #line-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 5;
      width: 100%;
      height: 100%;
    }
    #balloon-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none; /* balloons themselves use pointer-events:auto */
      z-index: 10;
    }
	
	.toolbar-group {
	  display: flex;
	  align-items: center;   /* ensures label + input align properly */
	  gap: 0.2em;            /* small spacing between label and input */
	}
	
    .balloon {
      position: absolute;
      padding: 4px 10px;
	  background: rgb(20, 171, 39);   /* default green */ 
      border-radius: 50px;
      color: white;
      text-align: center;
      font-weight: bold;
      border: 2px solid black;
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      cursor: grab;
      user-select: none;
      white-space: nowrap;
    }
	
	#textbox-layer {
	  position: absolute;
	  top: 0;
	  left: 0;
	  z-index: 15; /* above balloons */
	  pointer-events: none; /* individual textboxes will allow typing */
	  width: 100%;
	  height: 100%;
	}

	.textbox {
	  font-family: Helvetica, sans-serif;
	  position: absolute;
	  padding: 6px 8px;   /*  more inner padding: 6px top/bottom, 8px left/right */
	  resize: both;
	  overflow: auto;
	  cursor: text;
	  outline: none;
	  border: 1px solid #333; 					/* solid outline */
	  border-radius: 4px;
	  background: rgba(255,255,255,0.8);
	  pointer-events: auto; 					/* allow editing */
	}
	
	.textbox:focus {
	  border: 2px solid #007bff;   				/* blue border when editing */
	  background: rgba(255,255,255,1);
	}
	
	#footer {
	  margin-top: 2em;
	  padding: 1em;
	  background: #f0f0f0;
	  border-top: 1px solid #ccc;
	  font-size: 0.9em;
	  color: #333;
	}

	#footer h3 {
	  margin-top: 0;
	  font-size: 1.1em;
	}

	#footer ul {
	  padding-left: 1.2em;
	  margin: 0.5em 0 0;
	}

	#footer li {
	  margin: 0.4em 0;
	}

  </style>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";
  </script>

  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <div id="controls">
    <!-- Zoom controls -->
    <button id="zoom-out" title="Zoom out">‚àí</button>
    <input id="zoom-range" type="range" min="50" max="500" step="10" value="100" />
    <span id="zoom-level">100%</span>
	<button id="zoom-in" title="Zoom in">+</button>

    <input type="file" id="file-input" accept=".pdf,.png,.jpg,.jpeg,.webp" />
	
	<div class="toolbar-group">
		<label for="text-size">Balloon Text Size:</label>
		<input type="number" id="text-size" value="16" min="8" max="100" step="1" />
	</div>
	
    <div class="toolbar-group">
		<label for="balloon-color">Balloon Color:</label>
		<input type="color" id="balloon-color" value="#14ab27" />

	</div>
	
	<div class="toolbar-group">
		<label for="export-filename">Filename:</label>
		<input type="text" id="export-filename" value="ballooned" />
	</div>
	
    <button id="save-pdf-btn">Save as PDF</button>
    <button id="undo-btn">Undo</button>
	<button id="move-mode">Move</button>
    <button id="toggle-line-mode">Enable Leader Line Mode</button>
	<button id="toggle-textbox">Enable Text Box Mode</button>
	
	<div class="toolbar-group">
		<label for="textbox-size">Text Box Size:</label>
		<input type="number" id="textbox-size" value="14" min="8" max="100" step="1" />
	</div>
  </div>

  <div id="container">
    <canvas id="pdf-canvas"></canvas>
    <svg id="line-layer"></svg>
    <div id="balloon-layer"></div>
	<div id="textbox-layer"></div>
  </div>

  <script>
    // Globals
    let pdfDoc = null;
    let pageNum = 1;
    let scale = 1.0;                // user-visible zoom (1.0 = 100%)
    let originalFileName = 'document';
    let originalPageWidth = 0;
    let originalPageHeight = 0;
    let currentImage = null;        // store loaded image (if any)
	let moveMode = false;
	let isRendering = false;
	let pendingRender = null;
	let isTextBoxMode = false;

    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const balloonLayer = document.getElementById('balloon-layer');
    const lineLayer = document.getElementById('line-layer');
    const exportFilenameInput = document.getElementById('export-filename');
    const balloonColorInput = document.getElementById('balloon-color');
	const textboxSizeInput = document.getElementById("textbox-size");

    // Zoom UI
    const zoomRange = document.getElementById('zoom-range');
    const zoomLevelSpan = document.getElementById('zoom-level');
    const zoomInBtn = document.getElementById('zoom-in') || null; // may not exist in markup
    const zoomOutBtn = document.getElementById('zoom-out');

    // history + lines
    let historyStack = [];
    let leaderLineMode = false;
    let pendingBalloon = null;
    let lines = []; // {fromX,fromY,toX,toY,color,svgLine,fromBalloon,toBalloon,fromHandle,toHandle}

    // ---------- helper / history functions ----------
    function saveStateToHistory() {
	  const balloonData = [];
	  balloonLayer.querySelectorAll('.balloon').forEach(balloon => {
		const left = parseFloat(balloon.style.left) || 0;
		const top  = parseFloat(balloon.style.top) || 0;
		const width = balloon.offsetWidth;
		const height = balloon.offsetHeight;

		// Save normalized center coordinates (independent of zoom)
		const centerX = left + width / 2;
		const centerY = top + height / 2;

		balloonData.push({
		  text: balloon.textContent,
		  xNorm: centerX / canvas.width,
		  yNorm: centerY / canvas.height,
		  fontSize: parseFloat(balloon.style.fontSize) || 16,
		  color: balloon.style.backgroundColor
		});
	  });
	  
	  const lineData = lines.map(l => ({
		fromXNorm: l.fromX / canvas.width,
		fromYNorm: l.fromY / canvas.height,
		toXNorm:   l.toX / canvas.width,
		toYNorm:   l.toY / canvas.height,
		color: l.color,
		fromLabel: l.fromBalloon ? l.fromBalloon.textContent : null,
		toLabel:   l.toBalloon ? l.toBalloon.textContent : null
	  }));

	  historyStack.push({ balloons: balloonData, lines: lineData });
	}

    function restoreLastState() {
      if (historyStack.length < 2) return;
      historyStack.pop();
      const prev = historyStack[historyStack.length - 1];
	  
      balloonLayer.innerHTML = '';
      lineLayer.innerHTML = '';
      lines = [];
	  
	  const balloonMap = {}; // Rebuild balloons first and keep a lookup by text
      prev.balloons.forEach(d => {
        const b = createBalloonFromData(d);
        balloonLayer.appendChild(b);
		balloonMap[d.text] = b;
      });
	  
	  prev.lines.forEach(l => {
		const fromX = l.fromXNorm * canvas.width;
		const fromY = l.fromYNorm * canvas.height;
		const toX   = l.toXNorm   * canvas.width;
		const toY   = l.toYNorm   * canvas.height;
		
		const fromBalloon = balloonMap[l.fromLabel] || null;
		const toBalloon   = balloonMap[l.toLabel] || null;

		drawLineBetween(fromX, fromY, toX, toY, l.color, fromBalloon, toBalloon);
	  
      });
    }

    document.getElementById("move-mode").addEventListener("click", () => {
	  moveMode = !moveMode;
	  const btn = document.getElementById("move-mode");
	  btn.classList.toggle("active-btn", moveMode);
	});
		
	
	document.getElementById('undo-btn').addEventListener('click', restoreLastState);

    // ---------- file loading ----------
    document.getElementById('file-input').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;

      if (file.type === 'application/pdf') {
        currentImage = null;
        originalFileName = file.name.replace(/\.pdf$/i, '');
        exportFilenameInput.value = `${originalFileName} - ballooned`;

        const reader = new FileReader();
        reader.onload = function () {
          const typedarray = new Uint8Array(this.result);
          pdfjsLib.getDocument(typedarray).promise.then(pdf => {
            pdfDoc = pdf;
            // set initial scale (keeps previous value if user adjusted before loading)
            setPdfScale(scale);
            resetAnnotations();
            historyStack = [];
            saveStateToHistory();
          });
        };
        reader.readAsArrayBuffer(file);

      } else if (file.type.startsWith('image/')) {
        loadImageFile(file);
      } else {
        alert('Please select a PDF or an image file (PNG, JPG, JPEG, WEBP).');
      }
    });

    function loadImageFile(file) {
      const reader = new FileReader();
      reader.onload = function (e) {
        const img = new Image();
        img.onload = function () {
          currentImage = img;
          pdfDoc = null; // clear any loaded pdf
          originalFileName = file.name.replace(/\.[^/.]+$/, '');
          exportFilenameInput.value = `${originalFileName} - ballooned`;
          originalPageWidth = img.width;
          originalPageHeight = img.height;

          // draw at current scale
          setPdfScale(scale);

          resetAnnotations();
          historyStack = [];
          saveStateToHistory();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // ---------- rendering ----------
    // renderPage now RETURNS a promise so callers can chain after rendering completes
    function renderPage(num) {
      if (!pdfDoc) return Promise.resolve();
      return pdfDoc.getPage(num).then(page => {
        const unscaledViewport = page.getViewport({ scale: 1.0 });
        originalPageWidth = unscaledViewport.width;
        originalPageHeight = unscaledViewport.height;

        const viewport = page.getViewport({ scale });
        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);

        // adjust overlay sizes
        balloonLayer.style.width = canvas.width + 'px';
        balloonLayer.style.height = canvas.height + 'px';
        lineLayer.setAttribute('width', canvas.width);
        lineLayer.setAttribute('height', canvas.height);
        lineLayer.style.width = canvas.width + 'px';
        lineLayer.style.height = canvas.height + 'px';

        const renderContext = { canvasContext: ctx, viewport: viewport };
        return page.render(renderContext).promise;
      });
    }

    // ---------- annotation utilities ----------
    function resetAnnotations() {
      balloonLayer.innerHTML = '';
      lineLayer.innerHTML = '';
      lines = [];
      pendingBalloon = null;
    }

	function createBalloonFromData(data) {
	  const balloon = document.createElement('div');
	  balloon.className = 'balloon';
	  balloon.textContent = data.text;
	  balloon.style.fontSize = data.fontSize + 'px';
	  balloon.style.backgroundColor = data.color || balloonColorInput.value;
	  balloon.style.borderColor = darkenColor(balloon.style.backgroundColor, 0.6);

	  balloonLayer.appendChild(balloon);

	  // Compute current position from normalized coordinates
	  const centerX = data.xNorm * canvas.width;
	  const centerY = data.yNorm * canvas.height;

	  const rect = balloon.getBoundingClientRect();
	  const newLeft = centerX - rect.width / 2;
	  const newTop  = centerY - rect.height / 2;

	  balloon.style.left = newLeft + 'px';
	  balloon.style.top  = newTop + 'px';

	  attachBalloonEvents(balloon);
	  return balloon;
	}

    function darkenColor(color, factor = 0.7) {
      if (!color) return color;
      if (color.startsWith('#')) {
        let r = parseInt(color.substr(1,2),16),
            g = parseInt(color.substr(3,2),16),
            b = parseInt(color.substr(5,2),16);
        r = Math.floor(r * factor); g = Math.floor(g * factor); b = Math.floor(b * factor);
        return `rgb(${r},${g},${b})`;
      }
      return color;
    }

    function createNewBalloon(x, y, fontSize) {
      const color = balloonColorInput.value;
      const text = getNextBalloonNumber().toString();

      const balloon = document.createElement('div');
      balloon.className = 'balloon';
      balloon.textContent = text;
      balloon.style.fontSize = fontSize + 'px';
      balloon.style.backgroundColor = color;
      balloon.style.borderColor = darkenColor(color, 0.6);

      balloonLayer.appendChild(balloon);
      const rect = balloon.getBoundingClientRect();
      // containerRect used for center alignment calculation
      const containerRect = balloonLayer.getBoundingClientRect();
      const left = x - rect.width / 2;
      const top = y - rect.height / 2;
      balloon.style.left = left + 'px';
      balloon.style.top = top + 'px';

      attachBalloonEvents(balloon);
      return balloon;
    }


    function getNextBalloonNumber() {
      const all = balloonLayer.querySelectorAll('.balloon');
      let max = 0;
      all.forEach(b => {
        const num = parseInt(b.textContent);
        if (!isNaN(num) && num > max) max = num;
      });
      return max + 1;
    }
	
	// Helper: split balloon label into base number + suffix (e.g. "9a" -> { base: 9, suffix: "a" })
	// Helper: split label into either a number or a single letter
	
	function splitLabel(text) {
	  const t = String(text || '').trim();

	  // Pure number?
	  if (/^\d+$/.test(t)) {
		return { type: "number", base: parseInt(t, 10), suffix: "" };
	  }

	  // Starts with digits + suffix
	  const match = t.match(/^(\d+)(.+)$/);
	  if (match) {
		return { type: "numberSuffix", base: parseInt(match[1], 10), suffix: match[2] };
	  }

	  // Single letter (A, b, etc.)
	  if (/^[a-zA-Z]$/.test(t)) {
		return { type: "letter", value: t };
	  }

	  // Everything else
	  return { type: "other", value: t };
	}


	function renumberAfterDeletion(deletedLabel) {
	  const info = splitLabel(deletedLabel);

	  // Case 1: deleted was a number or number+suffix
	  if (info.type === "number" || info.type === "numberSuffix") {
		balloonLayer.querySelectorAll('.balloon').forEach(b => {
		  const bi = splitLabel(b.textContent);

		  if ((bi.type === "number" || bi.type === "numberSuffix") && bi.base > info.base) {
			// Shift down the base
			b.textContent = (bi.base - 1) + (bi.suffix || "");
		  }
		});
	  }

	  // Case 2: deleted was a letter
	  else if (info.type === "letter") {
		balloonLayer.querySelectorAll('.balloon').forEach(b => {
		  const bi = splitLabel(b.textContent);

		  if (bi.type === "letter" && bi.value > info.value) {
			b.textContent = String.fromCharCode(bi.value.charCodeAt(0) - 1);
		  }
		});
	  }

	  // Case 3: "other" ‚Üí no renumbering
	}
	
    // drag/edit/delete balloons (same logic as before)
    function attachBalloonEvents(balloon) {
      let isDragging = false;
      let offsetX, offsetY;

      balloon.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.stopPropagation();
        isDragging = true;
        const rect = balloon.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const containerRect = balloonLayer.getBoundingClientRect();
        const x = e.clientX - containerRect.left - offsetX;
        const y = e.clientY - containerRect.top - offsetY;
        const gridSize = 20; // px per grid cell
		const snapX = Math.round(x / gridSize) * gridSize;
		const snapY = Math.round(y / gridSize) * gridSize;
		
		balloon.style.left = snapX + 'px';
		balloon.style.top = snapY + 'px';
        updateLinesForBalloon(balloon);
      });

      document.addEventListener('mouseup', e => {
        if (isDragging) {
          isDragging = false;
          document.body.style.userSelect = '';
          saveStateToHistory();
        }
      });

      balloon.addEventListener('click', e => {
        e.stopPropagation();
		if (!moveMode) {
			const newText = prompt('Edit balloon text:', balloon.textContent);
			if (newText !== null && newText.trim() !== '') {
			  balloon.textContent = newText.trim();
			  const fontSize = parseInt(document.getElementById('text-size').value) || 16;
			  balloon.style.fontSize = fontSize + 'px';

			  // keep center
			  const rect = balloon.getBoundingClientRect();
			  const containerRect = balloonLayer.getBoundingClientRect();
			  const centerX = rect.left - containerRect.left + rect.width / 2;
			  const centerY = rect.top - containerRect.top + rect.height / 2;

			  balloon.style.left = '0px';
			  balloon.style.top = '0px';
			  const newRect = balloon.getBoundingClientRect();
			  const newLeft = centerX - newRect.width / 2;
			  const newTop = centerY - newRect.height / 2;

			  balloon.style.left = newLeft + 'px';
			  balloon.style.top = newTop + 'px';
			  saveStateToHistory();
			}
		}
      });

      balloon.addEventListener('contextmenu', e => {
		  e.preventDefault();
		  e.stopPropagation();

		  const shouldRenumber = confirm('Renumber balloons after deleting?');
		  
		  const deletedLabel = balloon.textContent;
		  // remove balloon and its connected lines
		  balloon.remove();
		  removeLinesConnectedTo(balloon);

		  if (shouldRenumber) {
			renumberAfterDeletion(deletedLabel);
		  }

		  saveStateToHistory();
		});

    }

    function updateLinesForBalloon(balloon) {
      const rect = balloon.getBoundingClientRect();
      const containerRect = balloonLayer.getBoundingClientRect();
      const centerX = rect.left - containerRect.left + rect.width / 2;
      const centerY = rect.top - containerRect.top + rect.height / 2;
      const newColor = balloon.style.backgroundColor;

      lines.forEach((line, index) => {
        let updated = false;
        if (line.fromBalloon === balloon) {
          line.fromX = centerX;
          line.fromY = centerY;
          line.color = newColor;
          updated = true;
        }
        if (line.toBalloon === balloon) {
          line.toX = centerX;
          line.toY = centerY;
          line.color = newColor;
          updated = true;
        }
        if (updated) updateLineSVG(index, line);
      });
    }

    function approxEqual(a, b, tolerance = 3) {
      return Math.abs(a - b) < tolerance;
    }

    function removeLinesConnectedTo(balloon) {
	  lines = lines.filter(line => {
		const connected = (line.fromBalloon?.isSameNode(balloon)) ||
						  (line.toBalloon?.isSameNode(balloon));
		if (connected) {
		  line.svgLine?.remove();
		  line.fromHandle?.remove();
		  line.toHandle?.remove();
		}
		return !connected;
	  });
	}


    function updateLineSVG(index, line) {
      const svgLine = line.svgLine;
      if (svgLine) {
        svgLine.setAttribute('x1', line.fromX);
        svgLine.setAttribute('y1', line.fromY);
        svgLine.setAttribute('x2', line.toX);
        svgLine.setAttribute('y2', line.toY);
        svgLine.setAttribute('stroke', line.color);
        if (line.fromHandle) {
          line.fromHandle.setAttribute('cx', line.fromX);
          line.fromHandle.setAttribute('cy', line.fromY);
        }
        if (line.toHandle) {
          line.toHandle.setAttribute('cx', line.toX);
          line.toHandle.setAttribute('cy', line.toY);
        }
      }
    }

    function drawLineBetween(x1, y1, x2, y2, color = balloonColorInput.value, fromBalloon = null, toBalloon = null) {
	  const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
	  lineEl.setAttribute('x1', x1);
	  lineEl.setAttribute('y1', y1);
	  lineEl.setAttribute('x2', x2);
	  lineEl.setAttribute('y2', y2);
	  lineEl.setAttribute('stroke', color);
	  lineEl.setAttribute('stroke-width', '2');
	  lineLayer.appendChild(lineEl);

	  const currentLine = {
		fromX: x1, fromY: y1,
		toX: x2, toY: y2,
		color, svgLine: lineEl,
		fromBalloon, toBalloon,
		fromHandle: null, toHandle: null
	  };

	  // create draggable handles
	  const fromHandle = createLineHandle(x1, y1, color, (nx, ny) => {
		currentLine.fromX = nx;
		currentLine.fromY = ny;
		updateLineSVG(lines.indexOf(currentLine), currentLine);
	  });
	  const toHandle = createLineHandle(x2, y2, color, (nx, ny) => {
		currentLine.toX = nx;
		currentLine.toY = ny;
		updateLineSVG(lines.indexOf(currentLine), currentLine);
	  });

	  lineLayer.appendChild(fromHandle);
	  lineLayer.appendChild(toHandle);

	  currentLine.fromHandle = fromHandle;
	  currentLine.toHandle = toHandle;

	  lines.push(currentLine);
	  updateLineSVG(lines.length - 1, currentLine);
	}


    // ---------- line handles (optional) ----------
    // kept for completeness ‚Äî you can hook handle creation to selection if desired
    function createLineHandle(x, y, color, onDrag) {
      const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      handle.setAttribute('cx', x);
      handle.setAttribute('cy', y);
      handle.setAttribute('r', 6);
      handle.setAttribute('fill', 'white');
      handle.setAttribute('stroke', color);
      handle.setAttribute('stroke-width', 2);
      handle.style.cursor = 'move';
      handle.style.pointerEvents = 'all';

      let isDragging = false;
      handle.addEventListener('mousedown', e => { e.stopPropagation(); isDragging = true; });
      document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        const nx = e.clientX - rect.left;
        const ny = e.clientY - rect.top;
        handle.setAttribute('cx', nx);
        handle.setAttribute('cy', ny);
        onDrag(nx, ny);
      });
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          saveStateToHistory();
        }
      });

      return handle;
    }
	
	// -------------Text Box Size Input -------------------------- //
	textboxSizeInput.addEventListener("input", () => {
	  const size = parseInt(textboxSizeInput.value) || 14;

	  // If a textbox is focused (clicked into), change its font size
	  const active = document.activeElement;
	  if (active && active.classList.contains("textbox")) {
		active.style.fontSize = size + "px";
		saveStateToHistory();
	  }
	});
	
	function trackTextBoxResize(tb) {
	  const observer = new ResizeObserver(() => {
		tb.dataset.wNorm = tb.offsetWidth / canvas.width;
		tb.dataset.hNorm = tb.offsetHeight / canvas.height;
	  });
	  observer.observe(tb);
	}
	
	// -------------Text Box Drag Function -----------------------//
	function makeTextBoxDraggable(tb) {
	  let isDragging = false;
	  let offsetX = 0, offsetY = 0;

	  tb.addEventListener("mousedown", e => {
		// Only start drag if:
		// - clicked directly on the box
		// - not inside text editing
		// - not on the resize handle
		if (e.target !== tb) return;

		const rect = tb.getBoundingClientRect();
		const border = 8; // pixels near edge = resize zone
		const withinResize =
		  e.offsetX > rect.width - border ||
		  e.offsetY > rect.height - border;

		if (withinResize) return; // let browser handle resizing

		isDragging = true;
		const containerRect = textboxLayer.getBoundingClientRect();
		offsetX = e.clientX - rect.left;
		offsetY = e.clientY - rect.top;
		e.preventDefault();
	  });

	  document.addEventListener("mousemove", e => {
		if (!isDragging) return;
		const containerRect = textboxLayer.getBoundingClientRect();
		const x = e.clientX - containerRect.left - offsetX;
		const y = e.clientY - containerRect.top - offsetY;
		tb.style.left = x + "px";
		tb.style.top = y + "px";
		tb.dataset.xNorm = x / canvas.width;
		tb.dataset.yNorm = y / canvas.height;

	  });

	  document.addEventListener("mouseup", () => {
		if (isDragging) {
		  isDragging = false;
		  saveStateToHistory();
		}
	  });
	}
	
    // ---------- leader line mode toggle + clicks to create balloons/lines ----------
    document.getElementById('toggle-line-mode').addEventListener('click', () => {
	  leaderLineMode = !leaderLineMode;
	  pendingBalloon = null;

	  const btn = document.getElementById('toggle-line-mode');
	  btn.textContent = leaderLineMode ? 'Disable Leader Line Mode' : 'Enable Leader Line Mode';
	  btn.classList.toggle('active-btn', leaderLineMode);
	});

    canvas.addEventListener('click', e => {
	  
	  if (isTextBoxMode) return; // skip balloon creation if text mode is on
      
	  const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const textSize = parseInt(document.getElementById('text-size').value) || 16;

      if (leaderLineMode) {
        if (!pendingBalloon) {
          saveStateToHistory();
          const balloon = createNewBalloon(x, y, textSize);
          pendingBalloon = { balloon, centerX: x, centerY: y };
        } else {
          saveStateToHistory();
          drawLineBetween(pendingBalloon.centerX, pendingBalloon.centerY, x, y, pendingBalloon.balloon.style.backgroundColor, pendingBalloon.balloon, null);
          pendingBalloon = null;
        }
      } else {
        saveStateToHistory();
        createNewBalloon(x, y, textSize);
      }
    });
	
	// --------------Text Box -------------------------------
	document.getElementById("toggle-textbox").addEventListener("click", () => {
	  isTextBoxMode = !isTextBoxMode;

	  const btn = document.getElementById("toggle-textbox");
	  btn.textContent = isTextBoxMode ? "Disable Text Box Mode" : "Enable Text Box Mode";
	  btn.classList.toggle("active-btn", isTextBoxMode);

	  textboxLayer.style.pointerEvents = isTextBoxMode ? "auto" : "none";
	});
	
	let currentTextBox = null;
	let startX, startY;

	const textboxLayer = document.getElementById("textbox-layer");

	textboxLayer.addEventListener("mousedown", e => {
	  if (!isTextBoxMode) return;
	  
	  if (e.target.classList.contains("textbox") || e.target.closest(".textbox")) {
		return; // If clicking inside an existing textbox, do nothing (let it be resized/edited)
	  }
	  
	  const startX = e.offsetX;
	  const startY = e.offsetY;
	  
	  currentTextBox = document.createElement("div"); 
	  
	  currentTextBox.classList.add("textbox");
	  currentTextBox.contentEditable = "true";
	  currentTextBox.style.left = startX + "px";
	  currentTextBox.style.top = startY + "px";
	  currentTextBox.style.minWidth = "50px";
	  currentTextBox.style.minHeight = "20px";
	  currentTextBox.style.fontSize = textboxSizeInput.value + "px";

	  // store normalized position/size so zoom works
		currentTextBox.dataset.xNorm = startX / canvas.width;
		currentTextBox.dataset.yNorm = startY / canvas.height;
		currentTextBox.dataset.wNorm = (parseFloat(currentTextBox.style.width) || 50) / canvas.width;
		currentTextBox.dataset.hNorm = (parseFloat(currentTextBox.style.height) || 20) / canvas.height;

	  textboxLayer.appendChild(currentTextBox);
	  makeTextBoxDraggable(currentTextBox);
	  trackTextBoxResize(currentTextBox);

	  function resize(eMove) {
		currentTextBox.style.width = (eMove.offsetX - startX) + "px";
		currentTextBox.style.height = (eMove.offsetY - startY) + "px";
	  }

	  function stop() {
		textboxLayer.removeEventListener("mousemove", resize);
		textboxLayer.removeEventListener("mouseup", stop);
		currentTextBox.focus();
		// normalize final size
		currentTextBox.dataset.wNorm = (parseFloat(currentTextBox.style.width) || currentTextBox.offsetWidth) / canvas.width;
		currentTextBox.dataset.hNorm = (parseFloat(currentTextBox.style.height) || currentTextBox.offsetHeight) / canvas.height;

		saveStateToHistory();
	  }

	  textboxLayer.addEventListener("mousemove", resize);
	  textboxLayer.addEventListener("mouseup", stop);
	});

	
    // ---------- export to PDF (lines + balloons scaled back to original doc size) ----------
    document.getElementById('save-pdf-btn').addEventListener('click', async () => {
      try {
        // choose export filename
        const filename = exportFilenameInput.value.trim() || `${originalFileName}-ballooned`;
        const { jsPDF } = window.jspdf;

        // If originalPageWidth/Height are in points for PDF case; for images we used pixels
        const isLandscape = originalPageWidth > originalPageHeight;
        const pdf = new jsPDF({
          orientation: isLandscape ? 'landscape' : 'portrait',
          unit: 'pt',
          format: [originalPageWidth, originalPageHeight],
        });

        // scale factors from current canvas (display size) back to original doc size
        const scaleX = originalPageWidth / canvas.width;
        const scaleY = originalPageHeight / canvas.height;

        const imgData = canvas.toDataURL('image/jpeg');
        pdf.addImage(imgData, 'JPEG', 0, 0, originalPageWidth, originalPageHeight);

        // draw lines
        lines.forEach(line => {
          const rgb = parseCssColor(line.color);
          if (rgb) pdf.setDrawColor(rgb.r, rgb.g, rgb.b);
          else pdf.setDrawColor(0,0,0);
		  
          pdf.setLineWidth(1);
          pdf.line(line.fromX * scaleX, line.fromY * scaleY, line.toX * scaleX, line.toY * scaleY);
        });

        // draw balloons as ellipses & text
        balloonLayer.querySelectorAll('.balloon').forEach(balloon => {
          const left = parseFloat(balloon.style.left) || 0;
          const top = parseFloat(balloon.style.top) || 0;
          const rect = balloon.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;
          const text = balloon.textContent;
          const fontSize = parseFloat(window.getComputedStyle(balloon).fontSize) || 16;

          const fillRgb = parseCssColor(balloon.style.backgroundColor);
          if (fillRgb) pdf.setFillColor(fillRgb.r, fillRgb.g, fillRgb.b);
          else pdf.setFillColor(255,0,0);
          pdf.setDrawColor(0,0,0);
          pdf.setLineWidth(2);

          const scaledLeft = left * scaleX;
          const scaledTop  = top  * scaleY;
          const scaledWidth = width * scaleX;
          const scaledHeight = height * scaleY;
          const scaledFontSize = fontSize * scaleX;

          pdf.ellipse(scaledLeft + scaledWidth/2, scaledTop + scaledHeight/2, scaledWidth/2, scaledHeight/2, 'F');
          pdf.setTextColor(255,255,255);
          pdf.setFont("helvetica","bold");
          pdf.setFontSize(scaledFontSize);
          const yOffset = scaledFontSize * 0.35;
          pdf.text(text, scaledLeft + scaledWidth/2, scaledTop + scaledHeight/2 + yOffset, { align: 'center' });
        });
		
	  // Text box export
	  textboxLayer.querySelectorAll('.textbox').forEach(tb => {
		  const text = tb.innerText.trim();
		  if (!text) return;

		  // Use normalized values (fallback to measured if missing)
		  const xNorm = parseFloat(tb.dataset.xNorm) || (parseFloat(tb.style.left) || 0) / canvas.width;
		  const yNorm = parseFloat(tb.dataset.yNorm) || (parseFloat(tb.style.top) || 0) / canvas.height;
		  const wNorm = parseFloat(tb.dataset.wNorm) || tb.offsetWidth / canvas.width;
		  const hNorm = parseFloat(tb.dataset.hNorm) || tb.offsetHeight / canvas.height;

		  const left   = xNorm * originalPageWidth;
		  const top    = yNorm * originalPageHeight;
		  const width  = wNorm * originalPageWidth;
		  const height = hNorm * originalPageHeight;
		  
		  const fontSize = parseFloat(window.getComputedStyle(tb).fontSize) || 12;
		  const scaledFontSize = fontSize * (originalPageWidth / canvas.width);

		  // Draw solid white background
		  pdf.setFillColor(255, 255, 255);   // white
		  pdf.rect(left, top, width, height, "F");		  
		  
		  // Draw solid border
		  pdf.setDrawColor(0, 0, 0); // black
		  pdf.setLineWidth(1);
		  pdf.rect(left, top, width, height);

		  // Draw text inside
		  pdf.setFont("helvetica", "normal");
		  pdf.setFontSize(scaledFontSize);
		  pdf.setTextColor(0,0,0);

		  const wrapped = pdf.splitTextToSize(text, width - 4); //Padding (2) * 2
		  pdf.text(wrapped, left + 2, top + scaledFontSize, {
		   maxWidth: width - 4,
		   align: "left",
		   baseline: "top"
		  });
		});
	  
	  
        //pdf.save(filename + '.pdf');
		if ('showSaveFilePicker' in window) {
		  const options = {
			suggestedName: filename + '.pdf',
			types: [{
			  description: 'PDF Document',
			  accept: { 'application/pdf': ['.pdf'] }
			}],
		  };
		  const handle = await window.showSaveFilePicker(options);
		  const writable = await handle.createWritable();
		  await writable.write(await pdf.output('arraybuffer'));
		  await writable.close();
		  alert('PDF saved successfully!');
		} else {
		  // fallback for browsers that don't support it
		  pdf.save(filename + '.pdf');
		}
		
		//
      } catch (err) {
        console.error('Failed to save PDF', err);
        alert('Failed to save PDF: ' + err.message);
      }
    });

    // ---------- color parsing helper ----------
    function parseCssColor(color) {
      if (!color) return null;
      if (color.startsWith('rgb')) {
        const nums = color.match(/\d+/g);
        if (nums && nums.length >= 3) return { r: +nums[0], g: +nums[1], b: +nums[2] };
      } else if (color[0] === '#') {
        let r,g,b;
        if (color.length === 7) {
          r = parseInt(color.substr(1,2),16);
          g = parseInt(color.substr(3,2),16);
          b = parseInt(color.substr(5,2),16);
          return { r,g,b };
        } else if (color.length === 4) {
          r = parseInt(color[1] + color[1],16);
          g = parseInt(color[2] + color[2],16);
          b = parseInt(color[3] + color[3],16);
          return { r,g,b }; //aks
        }
      }
      return null;
    }

    // ---------- ZOOM logic (core) ----------
    // setPdfScale(newScale) will scale the canvas (PDF rendering or image redraw),
    // and scale/move existing balloons + lines so they stay at the same places
    function setPdfScale(newScale) {
      // clamp between allowed range:
      newScale = Math.max(0.5, Math.min(5.0, newScale));
      const oldW = canvas.width || 0;
      const oldH = canvas.height || 0;

      if (pdfDoc) {
        // For PDF: compute new viewport size and scale everything accordingly,
        // then re-render the PDF page.
        pdfDoc.getPage(pageNum).then(page => {
          const newViewport = page.getViewport({ scale: newScale });
          const newW = Math.round(newViewport.width);
          const newH = Math.round(newViewport.height);
          const sx = oldW ? (newW / oldW) : 1;
          const sy = oldH ? (newH / oldH) : 1;

          // scale balloons
          balloonLayer.querySelectorAll('.balloon').forEach(b => {
            const left = parseFloat(b.style.left) || 0;
            const top = parseFloat(b.style.top) || 0;
            const rect = b.getBoundingClientRect();
            const centerX = left + rect.width / 2;
            const centerY = top + rect.height / 2;
            const newCenterX = centerX * sx;
            const newCenterY = centerY * sy;
            const newLeft = newCenterX - (rect.width * sx) / 2;
            const newTop  = newCenterY - (rect.height * sy) / 2;
            const fs = parseFloat(window.getComputedStyle(b).fontSize) || parseFloat(b.style.fontSize) || 16;
            b.style.fontSize = (fs * sx) + 'px';
            b.style.left = newLeft + 'px';
            b.style.top = newTop + 'px';
          });
		  
		  // scale textboxes
			textboxLayer.querySelectorAll('.textbox').forEach(tb => {
			  const x = parseFloat(tb.dataset.xNorm) * newW;
			  const y = parseFloat(tb.dataset.yNorm) * newH;
			  tb.style.left = x + "px";
			  tb.style.top = y + "px";

			});

          // scale free-floating line endpoints
          lines.forEach((line, idx) => {
            if (!line.fromBalloon) { line.fromX *= sx; line.fromY *= sy; }
            if (!line.toBalloon)   { line.toX *= sx;   line.toY *= sy; }
            if (line.svgLine) updateLineSVG(idx, line);
          });

          // update overlay sizes immediately so position calculations are correct
          balloonLayer.style.width = newW + 'px';
          balloonLayer.style.height = newH + 'px';
          lineLayer.setAttribute('width', newW);
          lineLayer.setAttribute('height', newH);
          lineLayer.style.width = newW + 'px';
          lineLayer.style.height = newH + 'px';

          // update global scale var and render
          scale = newScale;
          return renderPage(pageNum);
        }).then(() => {
          // after render we recalc lines that are attached to balloons to match their centers
          balloonLayer.querySelectorAll('.balloon').forEach(b => updateLinesForBalloon(b));
          zoomRange.value = Math.round(scale * 100);
          zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
        }).catch(err => console.error('Scaling PDF failed', err));
      } else if (currentImage) {
        // For image: compute new image size and redraw
        const newW = Math.round(currentImage.width * newScale);
        const newH = Math.round(currentImage.height * newScale);
        const sx = oldW ? (newW / oldW) : 1;
        const sy = oldH ? (newH / oldH) : 1;

        // scale balloons
        balloonLayer.querySelectorAll('.balloon').forEach(b => {
          const left = parseFloat(b.style.left) || 0;
          const top = parseFloat(b.style.top) || 0;
          const rect = b.getBoundingClientRect();
          const centerX = left + rect.width / 2;
          const centerY = top + rect.height / 2;
          const newCenterX = centerX * sx;
          const newCenterY = centerY * sy;
          const newLeft = newCenterX - (rect.width * sx) / 2;
          const newTop  = newCenterY - (rect.height * sy) / 2;
          const fs = parseFloat(window.getComputedStyle(b).fontSize) || parseFloat(b.style.fontSize) || 16;
          b.style.fontSize = (fs * sx) + 'px';
          b.style.left = newLeft + 'px';
          b.style.top = newTop + 'px';
        });
		
		// scale textboxes
		textboxLayer.querySelectorAll('.textbox').forEach(tb => {
		  const x = parseFloat(tb.dataset.xNorm) * newW;
		  const y = parseFloat(tb.dataset.yNorm) * newH;
		  tb.style.left = x + "px";
		  tb.style.top = y + "px";
		});

        // scale free-floating lines
        lines.forEach((line, idx) => {
          if (!line.fromBalloon) { line.fromX *= sx; line.fromY *= sy; }
          if (!line.toBalloon)   { line.toX *= sx;   line.toY *= sy; }
          if (line.svgLine) updateLineSVG(idx, line);
        });

        // resize canvas and redraw scaled image
        canvas.width = newW; canvas.height = newH;
        balloonLayer.style.width = newW + 'px';
        balloonLayer.style.height = newH + 'px';
        lineLayer.setAttribute('width', newW);
        lineLayer.setAttribute('height', newH);
        lineLayer.style.width = newW + 'px';
        lineLayer.style.height = newH + 'px';

        ctx.clearRect(0,0,newW,newH);
        ctx.drawImage(currentImage, 0, 0, newW, newH);

        scale = newScale;
        // recompute lines attached to balloons
        balloonLayer.querySelectorAll('.balloon').forEach(b => updateLinesForBalloon(b));
        zoomRange.value = Math.round(scale * 100);
        zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
      } else {
        // nothing loaded yet, just store scale
        scale = newScale;
        zoomRange.value = Math.round(scale * 100);
        zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
      }
    }

    // ---------- zoom UI wiring ---------- //
    zoomRange.addEventListener('input', () => {
      const val = Number(zoomRange.value) / 100;
      setPdfScale(val);
    });
    zoomOutBtn.addEventListener('click', () => {
      const newPerc = Math.max(50, Math.round(scale*100) - 10);
      setPdfScale(newPerc / 100);
    });
    document.getElementById('zoom-in').addEventListener('click', () => {
      const newPerc = Math.min(500, Math.round(scale*100) + 10);
      setPdfScale(newPerc / 100);
    });
	
	// --------------Delete text box with delete key------------- //
	document.addEventListener("keydown", e => {
	  if ((e.key === "Delete") &&
		  document.activeElement.classList.contains("textbox")) {
		const tb = document.activeElement;
		tb.remove();
		saveStateToHistory();
	  }
	});

    // ---------- initial UI values ---------- //
    zoomRange.value = Math.round(scale * 100);
    zoomLevelSpan.textContent = Math.round(scale * 100) + '%';


  </script>
  
    <footer id="footer">
    <h3>Verwendung</h3>
    <ul>
      <li>üìÇ Laden Sie eine PDF-Datei oder ein Bild √ºber die Schaltfl√§che ‚ÄûDatei ausw√§hlen‚Äú hoch.</li>
      <li>‚ûï Klicken Sie auf eine beliebige Stelle auf der Leinwand, um eine Sprechblasen-Anmerkung hinzuzuf√ºgen.</li>
      <li>‚úèÔ∏è Klicken Sie mit der rechten Maustaste auf eine Sprechblase, um sie zu l√∂schen (optional k√∂nnen Sie die anderen neu nummerieren).</li>
      <li>üìè Aktivieren Sie den ‚ÄûLeiterlinienmodus‚Äú, um Sprechblasen mit Linien zu verbinden.</li>
      <li>üìù Aktivieren Sie den ‚ÄûTextfeldmodus‚Äú, um Textfelder zu zeichnen und zu bearbeiten.</li>
      <li>üíæ Verwenden Sie ‚ÄûAls PDF speichern‚Äú, um Ihr mit Anmerkungen versehenes Dokument zu exportieren. Tipp: Speichern Sie die PDF-Datei mit derselben Zoomstufe, die Sie f√ºr die Bearbeitung verwendet haben, um Unstimmigkeiten zu vermeiden.</li>
	  <li>Hinweis: Die Gr√∂√üe der Sprechblase h√§ngt von der Zoomstufe ab. Eine Sprechblase mit der Textgr√∂√üe = 30 bei einer Zoomstufe von 400 % ist etwas kleiner als eine Sprechblase mit der Textgr√∂√üe = 30 bei einer Zoomstufe von 200 %.</li>
	  <li>Mit der Schaltfl√§che ‚ÄûR√ºckg√§ngig‚Äú werden alle Sprechblasengr√∂√üen f√ºr die aktuelle Zoomstufe neu geladen.</li>
	  <li>Die Qualit√§t und Dateigr√∂√üe der gespeicherten PDF-Datei h√§ngt von der Zoomstufe ab, mit der sie gespeichert wurde. Eine PDF-Datei, die mit einer Zoomstufe von 200 % gespeichert wurde, ist kleiner als eine PDF-Datei, die mit einer Zoomstufe von 500 % gespeichert wurde.</li>
	  <li>Da die App Zeit ben√∂tigt, um √Ñnderungen zu aktualisieren, k√∂nnen kontinuierliche und schnelle Zoom-/Klickvorg√§nge zu Fehlern aufgrund einer fehlerhaften Aktualisierung des Verlaufsstapels f√ºhren.</li>	  
    </ul>
  </footer>
 
</body>
</html>
